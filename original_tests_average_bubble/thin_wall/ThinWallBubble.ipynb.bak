{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Average Bubble Profile"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import math\n",
    "import matplotlib\n",
    "#matplotlib.rcParams.update({'font.size': 12})\n",
    "from matplotlib import gridspec\n",
    "import matplotlib.pyplot as plt\n",
    "from collections import deque\n",
    "import scipy as scp\n",
    "import scipy.optimize as sco\n",
    "import scipy.signal as scs\n",
    "import scipy.special as ssp\n",
    "import scipy.integrate as sci\n",
    "import scipy.interpolate as intp\n",
    "import statistics as stat\n",
    "import random\n",
    "from functools import partial\n",
    "from operator import eq\n",
    "from itertools import zip_longest, compress, count, islice\n",
    "from labellines import labelLine, labelLines"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Simulation Parameters "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "nLat = 2000\n",
    "nSims = 70\n",
    "minSim = 0\n",
    "simstep = 1\n",
    "\n",
    "nu = 2.*10**(-3)\n",
    "omega = 0.25 * 50. * 2. * np.sqrt(nu)\n",
    "delt = np.sqrt(nu / 2.) * (6. + 0.);\n",
    "rho = 200. * 2. * np.sqrt(nu) / 2.**3\n",
    "lamb = delt * np.sqrt(2. / nu); print('lamb = ', lamb)\n",
    "m2eff = 4. * nu * (- 1. + lamb**2); print('m2eff = ', m2eff)\n",
    "lenLat = 0.8 * 50. / np.sqrt(2. * nu); print('lenLat = ', lenLat)\n",
    "\n",
    "alpha = 8.\n",
    "nCols = 1\n",
    "phi0 = 2. * np.pi / 6.5; print('phi0 = ', phi0)\n",
    "phi_initial = np.pi\n",
    "dt_phi_initial = 0.\n",
    "\n",
    "nyq = nLat//2+1; spec = nyq; dx = lenLat/nLat; dk = 2.*np.pi/lenLat; dt = dx/alpha; dtout = dt*alpha\n",
    "light_cone = dtout/dx"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "instanton_location = '/home/dpirvu/inst/unstable/dev/thin_wall_instanton_interp.dat' #/np.sqrt(m2eff)/dx\n",
    "a = np.genfromtxt(instanton_location)\n",
    "coleman_bubble = 2*np.pi-a[:,1]\n",
    "xoffset = 50\n",
    "temp = coleman_bubble[len(coleman_bubble)//2-xoffset:len(coleman_bubble)//2+xoffset]\n",
    "peaks, _ = scs.find_peaks(temp)\n",
    "peaks = peaks\n",
    "fwhm, height, left_ips, right_ips = scs.peak_widths(temp, peaks, rel_height=0.5)\n",
    "radius_Coleman_bubble = max(fwhm)/2.\n",
    "filter_size = radius_Coleman_bubble\n",
    "print('filter_size = ', filter_size)\n",
    "\n",
    "plt.plot(np.arange(len(temp))-xoffset, temp)\n",
    "plt.plot(peaks-xoffset, temp[peaks], \"x\")\n",
    "#plt.hlines(*fwhm[1:], color='C2')\n",
    "[plt.hlines(height[i], left_ips[i]-xoffset, right_ips[i]-xoffset, color=\"C2\") for i in range(len(fwhm))]\n",
    "plt.xlabel(r'$r_{\\rm E}$'); plt.ylabel(r'$\\phi$')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def V(phi):\n",
    "    return ( -np.cos(phi) + 0.5 * lamb**2 * np.sin(phi)**2 ) * 4 * nu\n",
    "def dV(phi):\n",
    "    return ( np.sin(phi) + 0.5 * lamb**2 * np.sin(2*phi) ) * 4 * nu\n",
    "\n",
    "right_phi_at_V_max = sco.minimize_scalar(lambda x: -V(x), bounds=[np.pi, 2*np.pi], method='bounded')\n",
    "left_phi_at_V_max = sco.minimize_scalar(lambda x: -V(x), bounds=[0, np.pi], method='bounded')\n",
    "right_left_phi_at_V_max = sco.minimize_scalar(lambda x: -V(x), bounds=[2*np.pi, 3*np.pi], method='bounded')\n",
    "\n",
    "def F(x):\n",
    "    return V(x) - V(phi_initial)\n",
    "phi_upper_bound = sco.fsolve(F, 5.5)[0]\n",
    "phi_lower_bound = sco.fsolve(F, 0.5)[0]\n",
    "phi_upper_lower_bound = sco.fsolve(F, 6.5)[0]\n",
    "\n",
    "############################################################\n",
    "wall_tension, err = sci.quad(lambda x: np.sqrt(2*(V(x) - V(2*np.pi))), np.pi, 2*np.pi); print('wall_tension = ', wall_tension)\n",
    "epsilon = V(np.pi) - V(2*np.pi); print('epsilon = ', epsilon)\n",
    "R_coleman = wall_tension/epsilon; print('R_coleman = ', R_coleman)\n",
    "wall_thkn = right_phi_at_V_max.x / np.sqrt( V(right_phi_at_V_max.x) - V(np.pi) ); print('wall_thkn = ', wall_thkn)\n",
    "############################################################\n",
    "\n",
    "matplotlib.rcParams.update({'font.size': 12})\n",
    "fig = plt.figure(figsize=(7, 4))\n",
    "plt.plot([i for i in np.arange(0, 4*phi_initial, phi_initial/100)], [V(i) for i in np.arange(0, 4*phi_initial, phi_initial/100)])\n",
    "plt.plot(phi_upper_bound, V(phi_upper_bound), 'ro')\n",
    "plt.plot(phi_lower_bound, V(phi_lower_bound), 'co')\n",
    "plt.plot(phi_upper_lower_bound, V(phi_upper_lower_bound), 'yo')\n",
    "\n",
    "plt.plot(right_left_phi_at_V_max.x, V(right_left_phi_at_V_max.x), 'ko')\n",
    "[plt.plot(i*phi_initial, V(i*phi_initial), 'bo') for i in range(5)]\n",
    "[plt.axvline(left_phi_at_V_max.x + i*phi_initial, color='y', ls='--') for i in range(0,3,2)]\n",
    "[plt.axvline(right_phi_at_V_max.x + i*phi_initial, color='orange', ls='--') for i in range(0,3,2)]\n",
    "plt.xlabel(r'$\\phi(x)$'); plt.ylabel(r'$V(\\phi(x))$'); plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "titles = [r'$\\phi(x)$', r'$\\partial_t \\phi(x)$', r'$|\\nabla \\phi(x)|^2$', r'$V(\\phi(x))$']\n",
    "plots_file = '/home/dpirvu/big_plot_file/thin_wall_average_bubble/'\n",
    "pickle_location = '/home/dpirvu/pickle_location/thin_wall_average_bubble/'\n",
    "suffix = '_for_phi0{:.4f}'.format(phi0)+'_len{:.4f}'.format(lenLat)+'_lamb{:.4f}'.format(lamb)+'_x'+str(nLat)+'_spec'+str(spec)\n",
    "\n",
    "def bubbles_file(min, max):\n",
    "    return pickle_location+'bubbles_from_sim'+str(min)+'_up_to_sim'+str(max-1)+suffix+'.npy'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "np_load_old = np.load\n",
    "np.load = lambda *a,**k: np_load_old(*a, allow_pickle=True, **k)\n",
    "\n",
    "all_data, all_sims, sims_to_keep, sims_duration = np.load(bubbles_file(minSim, nSims))\n",
    "#all_data2, all_sims2, sims_to_keep2, sims_duration2 = np.load(bubbles_file(100, 200))\n",
    "#all_data = np.append(all_data1, all_data2)\n",
    "#all_sims = np.arange(len(all_data))\n",
    "#sims_to_keep = np.append(sims_to_keep1, sims_to_keep2)\n",
    "#sims_duration = np.append(sims_duration1, sims_duration2)\n",
    "print(sims_to_keep)\n",
    "\n",
    "np.load = np_load_old"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### VISUALISING SIMULATION DATA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_real_space_data(sim, col):\n",
    "#    pspec = [[abs(i*np.conj(i)) for i in field_slice] for field_slice in simulation]  \n",
    "    simulation = all_data[sim][col]\n",
    "#    sm_simulation = [smoothen(field_slice, sigma) for field_slice in simulation]\n",
    "    fig, ax0 = plt.subplots(1, 1, figsize = (7, 5))\n",
    "    im0 = ax0.imshow(simulation, aspect='auto', interpolation='none', origin='lower')#, extent=[0, dx*nLat, 0, dtout*sims_duration[sim]])\n",
    "#    im1 = ax1.imshow(sm_simulation, aspect='auto', interpolation='none', origin='lower')#, extent=[0, dx*nLat, 0, dtout*sims_duration[sim]])\n",
    "    clb = plt.colorbar(im0, ax = ax0); clb.set_label(titles[col], labelpad=-48, y=1.08, rotation=0)\n",
    "#    clb = plt.colorbar(im1, ax = ax1); clb.set_label(titles[col], labelpad=-28, y=1.08, rotation=0)\n",
    "    ax0.set(xlabel = r'$x$', ylabel = r'$t$')#; ax1.set(xlabel = r'$x$', ylabel = r'$t$')\n",
    "    plt.show()\n",
    "    return\n",
    "\n",
    "def plot_real_space_slice(sim, col, timeslice):\n",
    "    simulation = all_data[sim][col]\n",
    "    slice = simulation[timeslice]\n",
    "#    smooth_slice = matched_filter(slice)\n",
    "\n",
    "    plt.figure(figsize = (50, 3))\n",
    "    plt.plot(np.arange(len(slice)), slice, label=timeslice)\n",
    "    labelLines(plt.gca().get_lines(), xvals=(0, nLat//2), align=False)\n",
    "#    plt.plot(np.arange(len(smooth_slice)), smooth_slice, color='purple', ls='-')\n",
    "    plt.xlabel(r'$x$'); plt.ylabel(titles[col]); plt.legend(); plt.show()\n",
    "    return\n",
    "\n",
    "def add_mask(field_slice, threshold):\n",
    "    mask = [0 if -threshold <= field_slice[i] <= threshold else 1 for i in range(len(field_slice))]\n",
    "    return field_slice * mask\n",
    "\n",
    "def plot_masked_field(simulation, threshold):\n",
    "    plt.figure(figsize = (7, 4))\n",
    "    masked_field = [add_mask(field_slice, threshold) for field_slice in simulation]\n",
    "    im = ax.imshow(masked_field, aspect='auto', interpolation='none', origin='lower')#, extent=[0, dx*nLat, 0, dtout*sims_duration[sim]]) \n",
    "    clb = plt.colorbar(im, ax = ax)\n",
    "    ax.set(xlabel = r'$x$', ylabel=r'$t$')\n",
    "    plt.show()\n",
    "    return\n",
    "\n",
    "def smoothen(field_slice, sigma):\n",
    "    pbc = [j-1 if j < nLat/2+1 else nLat-j+1 for j in range(1, nLat+1)]\n",
    "    window = [np.exp(- 0.5 * (x*dx/sigma)**2) for x in pbc]\n",
    "    spectral_filter = np.fft.fft(np.asarray(window) / sum(window), len(field_slice))\n",
    "\n",
    "    fft_field_slice = np.fft.fft(field_slice, len(field_slice))\n",
    "    smooth_fft_field_slice = [spectral_filter[k] * fft_field_slice[k] for k in range(len(fft_field_slice))]\n",
    "    smooth_field_slice = np.fft.irfft(smooth_fft_field_slice, len(field_slice))\n",
    "    return [i.real for i in smooth_field_slice]\n",
    "\n",
    "def smoothen_without_PBC(field_slice, sigma):\n",
    "    pbc = [j-1 for j in range(1, nLat+1)]\n",
    "    window = [np.exp(- 0.5 * (x*dx/sigma)**2) / np.sqrt(2*np.pi) / sigma for x in pbc]\n",
    "    spectral_filter = np.fft.fft(np.asarray(window) / sum(window), len(field_slice))\n",
    "\n",
    "    fft_field_slice = np.fft.fft(field_slice, len(field_slice))\n",
    "    smooth_fft_field_slice = [spectral_filter[k] * fft_field_slice[k] for k in range(len(fft_field_slice))]\n",
    "    smooth_field_slice = np.fft.irfft(smooth_fft_field_slice, len(field_slice))\n",
    "    return [i.real for i in smooth_field_slice]\n",
    "\n",
    "def matched_filter(field_slice):\n",
    "    normalized_coleman_bubble = coleman_bubble/np.sum(coleman_bubble)\n",
    "    spectral_filter = np.fft.fft(normalized_coleman_bubble, len(field_slice))\n",
    "\n",
    "    fft_field_slice = np.fft.fft(field_slice, len(field_slice))\n",
    "    smooth_fft_field_slice = [spectral_filter[k] * fft_field_slice[k] for k in range(len(fft_field_slice))]\n",
    "    smooth_field_slice = np.fft.irfft(smooth_fft_field_slice, len(field_slice))\n",
    "    return [i.real for i in smooth_field_slice]\n",
    "\n",
    "def find_peak_positions(field_slice, peak_threshold):\n",
    "    \"\"\" Finds x coordinate of peaks in masked field with mask applied at threshold. \"\"\"\n",
    "    peak_coord = signal.find_peaks(field_slice, height = peak_threshold)[0].tolist()\n",
    "    if field_slice[-1] > peak_threshold and field_slice[0] > peak_threshold and field_slice[-1] != field_slice[0]:\n",
    "        if field_slice[0] > field_slice[-1] and field_slice[0] > field_slice[1]:\n",
    "            peak_coord.append(0)\n",
    "        elif field_slice[0] < field_slice[-1] and field_slice[-1] > field_slice[-2]:\n",
    "            peak_coord.append(len(field_slice)-1) # this minds potential boundary discontinuities\n",
    "    return peak_coord\n",
    "\n",
    "def find_max_peak(field_slice):\n",
    "    peak_coord = signal.find_peaks(field_slice)[0].tolist()\n",
    "    if field_slice[0] > field_slice[-1] and field_slice[0] > field_slice[1]:\n",
    "        peak_coord.append(0)\n",
    "    if field_slice[-1] > field_slice[0] and field_slice[-1] > field_slice[-2]:\n",
    "        peak_coord.append(len(field_slice)-1)\n",
    "    peak_heights = [field_slice[coord] for coord in peak_coord]\n",
    "    return field_slice.tolist().index(np.max(peak_heights)), np.max(peak_heights), peak_coord, peak_heights\n",
    "    \n",
    "def time_at_fraction(bubble, bubble_limit):\n",
    "    right_phi_x = [np.sum([1 for x in slice if 4*phi_initial > x >= np.floor(phi_upper_bound)]) for slice in bubble]\n",
    "    time_list = [t if (right_phi_x[t] <= len(bubble[0])*bubble_limit) else 0 for t in range(len(bubble))]\n",
    "    if np.count_nonzero(time_list != 0) > 0:\n",
    "        time = [e for e in time_list if e != 0][-1]\n",
    "    else:\n",
    "        time = 0\n",
    "    return time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for sim in all_sims[::2]:\n",
    "    simulation = np.concatenate((all_data[sim][0],all_data[sim][0],all_data[sim][0]), axis=1)\n",
    "    fig, ax0 = plt.subplots(1, 1, figsize = (8, 8))\n",
    "    im0 = ax0.imshow(simulation, aspect='auto', interpolation='none', origin='lower')#, extent=[0, dx*nLat, 0, dtout*sims_duration[sim]])\n",
    "    clb = plt.colorbar(im0, ax = ax0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def truncateNum(num, decimal_places):\n",
    "    StrNum = str(num)\n",
    "    p = StrNum.find(\".\") + 1 + decimal_places\n",
    "    return float(StrNum[0:p])\n",
    "\n",
    "def center_bubble(bubble0, bool):\n",
    "    tdecap = time_at_fraction(bubble0, 0.95)\n",
    "    frac = 0.7\n",
    "    tamp = time_at_fraction(bubble0, frac)\n",
    "    while tdecap-tamp < 50:\n",
    "        frac = frac - 0.05\n",
    "        tamp = time_at_fraction(bubble0, frac)\n",
    "    bubble = bubble0[tamp:tdecap+1]\n",
    "    T = len(bubble)\n",
    "    N = len(bubble[0])\n",
    "\n",
    "    fld = smoothen(bubble[-1], 5*dx)\n",
    "    limit = np.floor(phi_upper_bound)\n",
    "    vals = [x if (fld[x] > limit and fld[x-1] > limit) else 0 for x in range(1, N)]\n",
    "    first_zero = next((i for i, x in enumerate(vals) if x == 0.), None)\n",
    "    if first_zero is None:\n",
    "        first_zero = 0\n",
    "    bubble = [np.roll(bubble[t], -first_zero) for t in range(T)]\n",
    "    \n",
    "    fv = [[x for x in range(1, N) if (bubble[t][x] > limit and bubble[t][x-1] > limit)] for t in range(T)]\n",
    "    target_peak = int(round(np.mean([item for sublist in fv for item in sublist])))\n",
    "    angle = int(N//2) - (target_peak + first_zero)\n",
    "    \n",
    "    bubble0 = np.asarray([np.roll(bubble0[t], angle) for t in range(tdecap)])\n",
    "    \n",
    "    if bool:\n",
    "        exit_bubble = np.concatenate((bubble0, bubble0), axis=1)\n",
    "        TT = len(exit_bubble)\n",
    "        NN = len(exit_bubble[0])\n",
    "\n",
    "        # check which sides it travels\n",
    "        tcheck = time_at_fraction(bubble0, 0.05)\n",
    "        fld = smoothen(bubble0[tcheck], 5*dx)\n",
    "        peaks = [x for x in range(1, N) if (fld[x] > limit and fld[x-1] > limit)]\n",
    "#        print(tcheck, len(peaks), np.mean(peaks))\n",
    "        peaks = np.mean(peaks)\n",
    "        if peaks > N//2:\n",
    "            for t in np.arange(TT)[::-1]:\n",
    "                if int((TT-t)*light_cone/1.75) < NN - N:\n",
    "                    for x in range(N + int((TT-t)*light_cone/1.75), NN):\n",
    "                        exit_bubble[t][x] = phi_initial\n",
    "                if int((TT-t)*light_cone/1.75) > N - N//4:\n",
    "                    for x in range(int((TT-t)*light_cone/1.75) - N + N//4):\n",
    "                        exit_bubble[t][x] = phi_initial\n",
    "        else:\n",
    "            for t in np.arange(TT)[::-1]:\n",
    "                if NN + N//4 > int((TT-t)*light_cone/1.75):\n",
    "                    for x in range(NN + N//4 - int((TT-t)*light_cone/1.75), NN):\n",
    "                        exit_bubble[t][x] = phi_initial\n",
    "                if NN - N > int((TT-t)*light_cone/1.75):\n",
    "                    for x in range(NN - N - int((TT-t)*light_cone/1.75)):\n",
    "                        exit_bubble[t][x] = phi_initial\n",
    "    else:\n",
    "        TT = len(exit_bubble)\n",
    "        NN = len(exit_bubble[0])\n",
    "\n",
    "    if TT > int(NN//N) * nLat:\n",
    "        exitTT = int(NN//N) * nLat\n",
    "    else:\n",
    "        exitTT = TT\n",
    "    return exit_bubble[-TT::]\n",
    "\n",
    "def interpolate_bubble(bubble, res):\n",
    "    bubble = np.asarray(bubble)\n",
    "    t = np.arange(0, len(bubble))\n",
    "    x = np.arange(0, len(bubble[0]))\n",
    "    tt, xx = np.meshgrid(t, x)\n",
    "    z = bubble[tt, xx]\n",
    "    f = intp.interp2d(t, x, z, kind = 'quintic')\n",
    "    T = np.arange(0, len(t), 1/res)\n",
    "    X = np.arange(0, len(x), 1/res)\n",
    "    return f(T, X).T\n",
    "\n",
    "def gamma(v):\n",
    "    return ( 1. - v**2. )**(-0.5)\n",
    "\n",
    "def find_max(field_slice):\n",
    "    peak_coord = signal.find_peaks(field_slice)[0].tolist()\n",
    "    peak = max([field_slice[coord] for coord in peak_coord])\n",
    "    return field_slice.tolist().index(peak)\n",
    "\n",
    "def solve_system(uu, vv):\n",
    "    \"\"\" uu = wall travelling along with the com; vv = wall travelling against the com;\n",
    "    aa = centre of mass velocity; bb = instantaneous velocity of wall.\"\"\"\n",
    "    aa = ( 1 + uu*vv - np.sqrt( (-1 + uu**2)*(-1 + vv**2))) / ( uu + vv)\n",
    "    bb = (-1 + uu*vv + np.sqrt( (-1 + uu**2)*(-1 + vv**2))) / (-uu + vv)\n",
    "\n",
    "#    aa = ( 1 + uu*vv + np.sqrt( (-1 + uu**2)*(-1 + vv**2))) / ( uu + vv)\n",
    "#    bb = ( 1 - uu*vv + np.sqrt( (-1 + uu**2)*(-1 + vv**2))) / ( uu - vv)\n",
    "    return [uu, vv, aa, bb]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def tanh(x, r0L, r0R, dr, vL, vR):\n",
    "    wL = dr/gamma(vL)\n",
    "    wR = dr/gamma(vR)\n",
    "    return ( np.tanh( (x - r0L)/wL ) + np.tanh( (r0R - x)/wR ) ) * np.pi/2 + np.pi\n",
    "\n",
    "def tanh_fit(bubble_slice, axis, prior):\n",
    "    bounds = ((axis[0], 0, 0, 0, 0), (0, axis[-1], axis[-1], 1, 1))\n",
    "    if prior is not None:\n",
    "        best_tanh = sco.curve_fit(tanh, axis, bubble_slice, p0=prior, bounds=bounds)[0]\n",
    "    else:\n",
    "        best_tanh = sco.curve_fit(tanh, axis, bubble_slice, bounds=bounds)[0]\n",
    "#    plt.plot(axis, bubble_slice, 'ro', axis, [tanh(r, *best_tanh) for r in axis], 'g'); plt.show()\n",
    "    return best_tanh\n",
    "\n",
    "def hyperbola1(t, a, b, c):\n",
    "    return np.sqrt(c + (t - b)**2) + a\n",
    "def hyperbola2(t, d, e, f):\n",
    "    return - np.sqrt(f + (t - e)**2) + d\n",
    "\n",
    "def hypfit(tt, rr, qq):\n",
    "    \"\"\" No params in common; params in common: coords of the centres (a and b); or the acceleration (c)\"\"\"\n",
    "    if rr[0] <= rr[-1]:\n",
    "        fit1, pcov1 = sco.curve_fit(hyperbola1, tt, rr, p0 = (min(rr), tt[rr.index(min(rr))], 1e4))\n",
    "        fit2, pcov2 = sco.curve_fit(hyperbola2, tt, qq, p0 = (max(qq), tt[qq.index(max(qq))], 1e4))\n",
    "        traj1 = hyperbola1(tt, *fit1)\n",
    "        traj2 = hyperbola2(tt, *fit2)\n",
    "    else:\n",
    "        fit1, pcov1 = sco.curve_fit(hyperbola2, tt, rr, p0 = (max(rr), tt[rr.index(max(rr))], 1e4))\n",
    "        fit2, pcov2 = sco.curve_fit(hyperbola1, tt, qq, p0 = (min(qq), tt[qq.index(min(qq))], 1e4))\n",
    "        traj1 = hyperbola2(tt, *fit1)\n",
    "        traj2 = hyperbola1(tt, *fit2)\n",
    "    print('hyperbolic trajectories fit: ', fit1, fit2)\n",
    "#    plt.plot(tt, rr, 'g-', tt, qq, 'r-', tt, traj1, 'y:', tt, traj2, 'b:') # plot the equation using the fitted parameters\n",
    "    return traj1, traj2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def boost(vCOM, x, t):\n",
    "    return gamma(vCOM) * (x - vCOM*t) \n",
    "\n",
    "def boost_bubble(bubble, vCOM, res):\n",
    "    bound = 4*phi_initial\n",
    "    NT = len(bubble)\n",
    "    N = len(bubble[0])\n",
    "\n",
    "    # arbitrary t0 defined more or less as point where light rays meet (asymptotic to bounds of bubble at the end of t_{simulation})\n",
    "    t0 = int(time_at_fraction(bubble, 0.05)) # arbitrary choice of t0, but always established by the same criterium\n",
    "    x0 = int(np.round(np.mean([x for x in range(N) if bound > bubble[t0][x] > phi_upper_bound])))\n",
    "    print('t0, x0', t0, x0)\n",
    "\n",
    "    T0 = boost(vCOM, t0, x0)\n",
    "    X0 = boost(vCOM, x0, t0)\n",
    "    TT0 = T0\n",
    "    XX0 = X0\n",
    "    print('T0, X0', T0, X0)\n",
    "    i = 0.\n",
    "    while X0 < 0:\n",
    "        i -= 1\n",
    "        X0 = XX0 - i*N/3\n",
    "    while X0 > N:\n",
    "        i += 1\n",
    "        X0 = XX0 - i*N/3\n",
    "\n",
    "    j = 0.\n",
    "    while T0 < 0:\n",
    "        j -= 1\n",
    "        T0 = TT0 - j*NT/3\n",
    "    while T0 > NT:\n",
    "        j += 1\n",
    "        T0 = TT0 - j*NT/3\n",
    "    print('T0, X0', T0, X0)\n",
    "            \n",
    "    bubble = interpolate_bubble(bubble, res)\n",
    "    new_bubble = [[5*phi_initial for x in range(N)] for t in range(NT)]\n",
    "    if x0 > N//2:\n",
    "#        j -= 1.5\n",
    "#        i -= 1.5\n",
    "        for t in range(NT):\n",
    "            for x in range(N):\n",
    "                tt = int((boost(vCOM, t, x) - j*NT/3)*res)\n",
    "                xx = int((boost(vCOM, x, t) - i*N/3)*res)\n",
    "#                tt = int(boost(vCOM, t - j*NT/4, x - i*N/4)*res)\n",
    "#                xx = int(boost(vCOM, x - i*N/4, t - j*NT/4)*res)\n",
    "                if (NT*res > tt >= 0 and N*res > xx >= 0):\n",
    "                    new_bubble[t][x] = bubble[tt][xx]\n",
    "    if x0 < N//2:\n",
    "#        j -= 1\n",
    "#        i += 1\n",
    "        for t in range(NT):\n",
    "            for x in range(N):\n",
    "                tt = int((boost(vCOM, t, x) - j*NT/3)*res)\n",
    "                xx = int((boost(vCOM, x, t) - i*N/3)*res)\n",
    "#                tt = int(boost(vCOM, t+(NT-TT0), x-XX0)*res)\n",
    "#                xx = int(boost(vCOM, x-XX0, t+(NT-TT0))*res)\n",
    "                if (NT*res > tt >= 0 and N*res > xx >= 0):\n",
    "                    new_bubble[t][x] = bubble[tt][xx]\n",
    "    return new_bubble"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def center_bubble_again(bubble0, bool):\n",
    "    bound = 4*phi_initial\n",
    "    NT = len(bubble0)\n",
    "    N = len(bubble0[0])\n",
    "    count0, tmin, tmax, xmin, xmax = 0, 0, NT-1, 0, N-1\n",
    "    for t in range(NT):\n",
    "#        slice = smoothen_without_PBC([i for i in bubble0[t] if i < bound], 10*dx)\n",
    "        slice = bubble0[t]\n",
    "        count = len([i for i in slice if bound > i > phi_initial])\n",
    "        peaks = [i for i in slice if bound > i >= phi_upper_bound]\n",
    "        if count > count0 and peaks != 0:\n",
    "            count0 = count\n",
    "            tmax = t\n",
    "    for t in range(NT):\n",
    "        if not any([bound > bubble0[t][i] > phi_initial for i in range(N)]):\n",
    "            tmin = t\n",
    "        else:\n",
    "            break\n",
    "\n",
    "    bubble = bubble0[tmin:tmax]    \n",
    "    NT = len(bubble)\n",
    "\n",
    "    for x in range(N//2):\n",
    "        if not any([bound > bubble[i][x] > phi_initial for i in range(NT)]):\n",
    "            xmin = x\n",
    "        else:\n",
    "            break\n",
    "    for x in range(N-1, N//2, -1):\n",
    "        if not any([bound > bubble[i][x] > phi_initial for i in range(NT)]):\n",
    "            xmax = x\n",
    "        else:\n",
    "            break\n",
    "    bubble = [bubble[i][xmin:xmax+1] for i in range(NT)]\n",
    "    return bubble"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def velocity(bubble):\n",
    "    T, N, window = len(bubble), len(bubble[0]), int(nLat//8)\n",
    "    bubble = [[bubble[t][x] if bubble[t][x] < 4*phi_initial else phi_initial for x in range(N)] for t in range(T)]\n",
    "    ti, tf = 0, T-1\n",
    "    limit = phi_upper_bound\n",
    "\n",
    "    peaks = [i for i in range(N) if bubble[tf][i] >= limit]\n",
    "    while peaks[0] - window < 0 or peaks[-1] + window >= N:\n",
    "        tf -= 2\n",
    "        peaks = [i for i in range(N) if bubble[tf][i] >= limit]\n",
    "\n",
    "    time_list = np.arange(ti, tf)\n",
    "\n",
    "    data, target_location, x = [], [], []\n",
    "    for t in time_list[::-1]:\n",
    "        field_slice = bubble[t]\n",
    "        if any(i >= limit for i in field_slice):\n",
    "            if len(data) == 0:\n",
    "                peaks = [i for i in range(N) if field_slice[i] >= limit]\n",
    "                target = int(np.round(np.nanmean(peaks)))\n",
    "            else:\n",
    "                peaks = [i for i in range(target_location[-1]-window, target_location[-1]+window+1) if field_slice[i] >= limit]\n",
    "                if len(peaks) != 0:\n",
    "                    target = int(np.round(np.nanmean(peaks)))\n",
    "                else:\n",
    "                    target = field_slice.index(max(field_slice))\n",
    "        else:\n",
    "            break\n",
    "\n",
    "        if len(data) == 0:\n",
    "            coord_list = np.arange(peaks[0] - window, peaks[-1] + window)\n",
    "            prior = None\n",
    "        else:\n",
    "            coord_list = np.arange(target - int(np.round(np.abs(data[-1][0]))) - window, target + int(np.round(np.abs(data[-1][1]))) + window)\n",
    "            prior = data[-1]\n",
    "\n",
    "        # these bounds are such that the field does not wrap around the edges. therefore need frac < 0.8\n",
    "        bubble_slice = np.asarray([field_slice[i%N] for i in coord_list])                \n",
    "        axis = np.asarray([i-target for i in coord_list]) #(-target+coord_list[0], coord_list[-1]-target+1)\n",
    "        result = tanh_fit(bubble_slice, axis, prior)\n",
    "\n",
    "        target_location.append(target)\n",
    "        data.append(result)\n",
    "        x.append(t)\n",
    "\n",
    "    target_location = target_location[::-1]\n",
    "    data = data[::-1]\n",
    "    x = x[::-1]\n",
    "    print('tmin, tmax: ', x[0], x[-1])\n",
    "\n",
    "    # get velocities from best fit to wall velocity\n",
    "    radius_diff = [np.abs(i[0]) - np.abs(i[1]) for i in data] # left radius - right radius\n",
    "    if np.mean(radius_diff) > 0:  #average difference in radius\n",
    "        # then the left wall is farther than the right wall and the bubble is travelling to the right\n",
    "        rr = [target_location[i] + data[i][1] for i in range(len(data))]\n",
    "        qq = [target_location[i] + data[i][0] for i in range(len(data))]\n",
    "        uu = [i[-1] for i in data] # uu is the right wall & travelling along with the COM\n",
    "        vv = [i[-2] for i in data]\n",
    "    else:\n",
    "        rr = [target_location[i] + data[i][0] for i in range(len(data))]\n",
    "        qq = [target_location[i] + data[i][1] for i in range(len(data))]\n",
    "        uu = [i[-2] for i in data] # uu is the left wall & travelling along with the COM\n",
    "        vv = [i[-1] for i in data]\n",
    "\n",
    "    if rr[-1] < qq[-1]:\n",
    "        for r in np.arange(1, len(rr))[::-1]:\n",
    "            if rr[r] > N-10 and rr[r-1] < 10:\n",
    "                rr = [rr[i]+N for i in range(len(rr)) if i >= r]\n",
    "                qq = [qq[i]+N for i in range(len(qq)) if i >= r]\n",
    "                break\n",
    "    else:\n",
    "        for q in np.arange(1, len(qq))[::-1]:\n",
    "            if qq[q] > N-10 and qq[q-1] < 10:\n",
    "                qq = [qq[i]+N for i in range(len(qq)) if i >= q]\n",
    "                rr = [rr[i]+N for i in range(len(rr)) if i >= q]\n",
    "                break\n",
    "\n",
    "    # get velocities from derivative of best fit to wall trajectory\n",
    "    bestrr, bestqq = hypfit(x, rr, qq)\n",
    "    tckrr, tckqq = intp.splrep(x, bestrr), intp.splrep(x, bestqq)\n",
    "    drr, dqq = intp.splev(x, tckrr, der=1), intp.splev(x, tckqq, der=1)\n",
    "\n",
    "#    velocities = np.asarray([solve_system(uu[j], vv[j]) for j in range(len(uu))])\n",
    "    velocities = np.asarray([solve_system(drr[j], dqq[j]) for j in range(len(drr))])\n",
    "\n",
    "    fig, [ax0, ax1] = plt.subplots(1, 2, figsize = (15, 4))\n",
    "    ax0.plot(target_location, x, 'k', rr, x, 'b', qq, x, 'y', bestrr, x, 'r:', bestqq, x, 'r:', linewidth='3')\n",
    "    ax0.set_xlabel('x'); ax0.set_ylabel('t')\n",
    "\n",
    "    ax1.plot(x, velocities[:, 0], 'b:', x, velocities[:, 1], 'y:')\n",
    "    ax1.plot(x, velocities[:, 2], 'r', label=r'v COM')\n",
    "    ax1.plot(x, velocities[:, 3], 'g', label=r'v inst wall')\n",
    "    ax1.axhline(0, color='darkgray', ls=':')\n",
    "    ax1.set_xlabel('t'); ax1.set_ylabel('v(t)'); ax1.legend()\n",
    "    plt.savefig(plots_file+'velocity_profile'+str(random.randrange(100))+suffix+'.png');\n",
    "\n",
    "    list = np.abs(velocities[:, 2] - velocities[:, 3])\n",
    "    vCOM = -velocities[:, 2][list.tolist().index(np.min(list))]\n",
    "#    vCOM = -np.mean(velocities[:, 2])\n",
    "#    vCOM = -np.mean(velocities[0, 2])\n",
    "    print('v COM = ', vCOM)\n",
    "    return vCOM"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for sim in all_sims[::]:\n",
    "    resolution = 5\n",
    "\n",
    "    bubble = all_data[sim][0]\n",
    "    bubble = center_bubble(bubble, True)\n",
    "    beta = velocity(bubble)\n",
    "    i = 0\n",
    "    fig, ax = plt.subplots(1, 4, figsize = (22, 4))\n",
    "    ax[i].imshow(bubble, aspect='auto', interpolation='none', origin='lower')\n",
    "    while i < 3:\n",
    "        i+=1\n",
    "        fraction = 0.9\n",
    "        if np.abs(beta) < fraction:\n",
    "            bubble = boost_bubble(bubble, beta, resolution)\n",
    "#            bubble = center_bubble_again(bubble, False)\n",
    "            bubble = [[bubble[t][x] if bubble[t][x] < 4*phi_initial else phi_initial for x in range(len(bubble[0]))] for t in range(len(bubble))]\n",
    "            ax[i].imshow(bubble, aspect='auto', interpolation='none', origin='lower')\n",
    "            ax[i].set_title('vCOM = {:.2f}'.format(beta))\n",
    "            break\n",
    "        else:\n",
    "            bubble = boost_bubble(bubble, np.sign(beta)*fraction, resolution)\n",
    "            bubble = center_bubble_again(bubble, False)\n",
    "#            plt.figure()\n",
    "#            plt.imshow(bubble, aspect='auto', interpolation='none', origin='lower')\n",
    "#            plt.show()\n",
    "#            bubble = [[bubble[t][x] if bubble[t][x] < 4*phi_initial else phi_initial for x in range(len(bubble[0]))] for t in range(len(bubble))]\n",
    "            ax[i].imshow(bubble, aspect='auto', interpolation='none', origin='lower')\n",
    "            ax[i].set_title('vCOM = {:.2f}'.format(beta))\n",
    "            beta = velocity(bubble)\n",
    "#    new_bubble = translate_bubble(bubble, beta2, 2)\n",
    "    [ax[i].set(xlabel='x', ylabel='t') for i in range(3)]\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Average bubble"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cut_out_coordinates(bubble_limit):\n",
    "    bubble_data = []\n",
    "    for sim in all_sims:\n",
    "#       t_min, t_max = time_limits_of_bubble(sim, bubble_limit)\n",
    "        breakLoop = False\n",
    "        t_min, t_max = [], []\n",
    "        simulation = all_data[sim]\n",
    "        nT = len(simulation[0])\n",
    "        for t in range(nT):\n",
    "            if not breakLoop:\n",
    "                true_V = 0\n",
    "                for V_phi in simulation[-1][t]:\n",
    "                    if V_phi < V(np.pi): \n",
    "                        true_V += 1\n",
    "                if (true_V >= nLat * 0.14 or t == nT-1) :\n",
    "                    t_min.append(t)\n",
    "                if (true_V >= nLat * 0.17 or t == nT-1) :\n",
    "                    t_max.append(t)\n",
    "                if (true_V >= nLat * bubble_limit or t == nT-1) :\n",
    "                    t_end = t\n",
    "                    t_beginning = t_end - 250\n",
    "                    if t_beginning < 0 : t_beginning = 0\n",
    "                    breakLoop = True\n",
    "        if t_min != []:\n",
    "            time_list_averaging = np.arange(min(t_min), min(t_max)+1)[::-1]\n",
    "#            print(len(time_list_averaging))\n",
    "            time_bubble = np.arange(t_beginning, t_end+1)[::-1]\n",
    "            peak_list = []\n",
    "            if (t_end != nT-1) and (t_beginning != 0):\n",
    "                for t in time_list_averaging:\n",
    "                    field_slice = simulation[0][t]\n",
    "                    bubble_position_at_t = [x for x in range(len(field_slice)) if field_slice[x] > phi_upper_bound]\n",
    "                    if len(bubble_position_at_t) > 0:\n",
    "                        peak_list.append(np.mean(bubble_position_at_t))\n",
    "                \n",
    "                if len(peak_list) >= 2:\n",
    "                    if stat.stdev(peak_list) <= nLat*0.005:\n",
    "                        target_peak = int(round(np.mean(peak_list)))\n",
    "                        coord_list = np.arange(target_peak - nLat//2, target_peak + nLat//2)%nLat\n",
    "                        bubble_data.append((sim, coord_list, time_bubble))\n",
    "    print('# valid simulations: ', len(bubble_data))\n",
    "    return bubble_data\n",
    "\n",
    "def stack_bubbles(overall_bubble_data, col):\n",
    "    bubbles, time, average_bubble, average_bubble_error = [], [], [], []\n",
    "    for bubble_data in overall_bubble_data:\n",
    "        simulation, coord_list, time_bubble = bubble_data\n",
    "        if col != 1:\n",
    "            field = [[all_data[simulation][col][t][i] for i in coord_list] for t in time_bubble]\n",
    "        else:\n",
    "            field = [[all_data[simulation][col][t][i]**2 for i in coord_list] for t in time_bubble]\n",
    "        bubbles.append(field)\n",
    "        time.append(len(time_bubble))\n",
    "        n_coord = len(coord_list)\n",
    "\n",
    "    field = [ [ [ t for t in range(time[sim]) ] for sim in range(len(bubbles)) ] for coord in range(n_coord)]\n",
    "    for coord in range(n_coord):\n",
    "        for sim in range(len(bubbles)):\n",
    "            for t in range(time[sim]):\n",
    "                field[coord][sim][t] = bubbles[sim][t][coord]\n",
    "    for coordinate in field:\n",
    "        xerr_field = np.nanstd(np.array(list(zip_longest(*coordinate)), dtype=float), axis=1, ddof=1)\n",
    "        xerr_field = [x for x in xerr_field if str(x) != 'nan'][::-1]\n",
    "        average_bubble_error.append(xerr_field)\n",
    "        mean_field = np.nanmean(np.array(list(zip_longest(*coordinate)), dtype=float), axis=1)\n",
    "        average_bubble.append(mean_field[:len(xerr_field)][::-1])\n",
    "    return np.transpose(average_bubble, (1, 0)), np.transpose(average_bubble_error, (1, 0)), min(time)\n",
    "\n",
    "def coleman_match(average_bubble):\n",
    "    # Coleman solution from Mathematica file: ColemanBubble\n",
    "    decimal_places = 5\n",
    "    x_list = [x for x in range(len(coleman_bubble[0])) if truncateNum(coleman_bubble[0][x], decimal_places) != truncateNum(np.pi, decimal_places)]\n",
    "    y_list = [x for x in range(len(coleman_bubble[0])) if truncateNum(coleman_bubble[0][x], decimal_places) == truncateNum(2*np.pi, decimal_places)]\n",
    "    coord_list = [x for x in range(len(coleman_bubble[0])) if (x in x_list and x not in y_list)]\n",
    "    min_sum = np.sum(coleman_bubble[0])\n",
    "    min_t = 0\n",
    "    for t in range(len(average_bubble)):\n",
    "        a = sum([(average_bubble[t][x] - coleman_bubble[0][x])**2 for x in coord_list])\n",
    "        if min_sum > a:\n",
    "            min_sum = a\n",
    "            min_t = t\n",
    "    return min_t, min(x_list), max(x_list)#, min(y_list), max(y_list)\n",
    "    \n",
    "def plot_coleman_match(ab):\n",
    "    average_bubble, average_bubble_error, common_time = ab\n",
    "    t_coleman, a, b = coleman_match(average_bubble)\n",
    "    print('shape of bubble: ', np.shape(average_bubble))\n",
    "    print('t_coleman = ', t_coleman)\n",
    "    solution = average_bubble[t_coleman]\n",
    "    solution_error = average_bubble_error[t_coleman]\n",
    "    difference = [coleman_bubble[0][i] - solution[i] for i in range(len(coleman_bubble[0]))]\n",
    "\n",
    "    fig = plt.figure(figsize=(12,4)); plt.subplots_adjust(hspace=.0)\n",
    "    gs = gridspec.GridSpec(1, 2); ax = [[],[]]\n",
    "    ax[0] = plt.subplot(gs[0]); ax[1] = plt.subplot(gs[1])\n",
    "\n",
    "    im = ax[0].imshow(average_bubble, aspect='auto', interpolation='none', origin='lower')#, extent=[0, dx*len(average_bubble[0]), 0, dtout*len(average_bubble)])     \n",
    "    clb = plt.colorbar(im, ax = ax[0])\n",
    "    ax[0].set(xlabel = r'$x$', ylabel=r'$t$')\n",
    "    ax[0].plot(np.arange(len(solution)), np.ones(len(solution))*t_coleman, 'r-')\n",
    "    ax[0].plot(np.arange(len(solution)), np.ones(len(solution))*(len(average_bubble)-common_time), color='darkgray', ls='-', linewidth=0.5)\n",
    "\n",
    "    mask = []\n",
    "    for t in range(len(coleman_bubble)):\n",
    "        mask.append([])\n",
    "        for x in range(len(coleman_bubble[-1])):\n",
    "            if coleman_bubble[t][x] != 0.:\n",
    "                mask[-1].append(1.)\n",
    "            else:\n",
    "                mask[-1].append(0.)\n",
    "    extra_t = len(coleman_bubble)\n",
    "    if t_coleman + extra_t >= len(average_bubble):\n",
    "        extra_t = len(average_bubble) - t_coleman\n",
    "#    x, y = np.meshgrid(range(len(mask[0])), range(len(mask[:extra_t])))\n",
    "#    ax.contour(x, y, mask[:extra_t], levels=[0.5, 1.5], colors=('k',), linewidths=(1.5,), origin='lower')\n",
    "    im = ax[1].imshow((average_bubble[t_coleman:(t_coleman+extra_t):1]-coleman_bubble[:extra_t])*mask[:extra_t], aspect='auto', interpolation='none', origin='lower')#, extent=[0, dx*len(average_bubble[0]), 0, dtout*(len(average_bubble)-t_coleman)])\n",
    "    clb = plt.colorbar(im, ax = ax[1])\n",
    "    ax[1].set(xlabel = r'$x$', ylabel=r'$t$')\n",
    "    plt.savefig(plots_file+'bubble_solution_'+suffix+'.png');\n",
    "    plt.show()\n",
    "\n",
    "    fig = plt.figure(figsize=(10,5))\n",
    "    plt.errorbar(np.arange(len(solution)), solution, yerr = solution_error, color = 'k', marker='o', ms=1, ecolor = 'green', label = 'Average bubble')\n",
    "    plt.plot(np.arange(len(coleman_bubble[0])), coleman_bubble[0], 'r-', linewidth=5.0, label = 'Coleman best fit at t = '+str(t_coleman))\n",
    "    plt.errorbar(np.arange(len(coleman_bubble[0])), difference, yerr = solution_error, color = 'k', marker='o', ms=1, ecolor = 'yellow', label = 'Difference')\n",
    "    plt.axvline(a, color = 'darkgray', ls = '--'); plt.axvline(b, color = 'darkgray', ls = '--')\n",
    "#    plt.axvline(c, color = 'darkgray', ls = '--'); plt.axvline(d, color = 'darkgray', ls = '--')\n",
    "    plt.legend(); plt.savefig(plots_file+'bubble_profile_'+suffix+'.png'); plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def bubble_energies(bubble, bubble_mom_sq, bubble_gradient, bubble_potential):\n",
    "    average_bubble = bubble[0]; KED = 0.5*bubble_mom_sq[0]; GED = 0.5*bubble_gradient[0]; PED = bubble_potential[0]\n",
    "    return KED, GED, PED, KED + GED + PED\n",
    "\n",
    "def bubble_total_energy(bubble, bubble_mom_sq, bubble_gradient, bubble_potential):\n",
    "    energies = bubble_energies(bubble, bubble_mom_sq, bubble_gradient, bubble_potential)\n",
    "    return [ [sum(ED[t]) for t in range(len(ED))] for ED in energies ]\n",
    "\n",
    "def plot_total_energy_density(bubble, bubble_mom_sq, bubble_gradient, bubble_potential):\n",
    "    KED, GED, PED, TED = bubble_energies(bubble, bubble_mom_sq, bubble_gradient, bubble_potential)\n",
    "    t_coleman = coleman_match(bubble[0])[0]\n",
    "\n",
    "    fig = plt.figure(figsize=(15,10)); gs = gridspec.GridSpec(2, 2); ax = [[],[], [], []]\n",
    "    ax[0] = plt.subplot(gs[0]); ax[1] = plt.subplot(gs[1]); ax[2] = plt.subplot(gs[2]); ax[3] = plt.subplot(gs[3])\n",
    "    im = ax[0].imshow(KED, aspect='auto', interpolation='none', origin='lower')   \n",
    "    ax[0].plot(np.arange(len(bubble[0][t_coleman])), np.ones(len(bubble[0][t_coleman]))*t_coleman, 'r-')\n",
    "    clb = plt.colorbar(im, ax = ax[0]); ax[0].set_title(r'KED: $\\frac{1}{2}(\\partial_t \\phi)^2$'); ax[0].set(ylabel=r'$t$')\n",
    "    im = ax[1].imshow(GED, aspect='auto', interpolation='none', origin='lower')   \n",
    "    ax[1].plot(np.arange(len(bubble[0][t_coleman])), np.ones(len(bubble[0][t_coleman]))*t_coleman, 'r-')\n",
    "    clb = plt.colorbar(im, ax = ax[1]); ax[1].set_title(r'GED: $\\frac{1}{2}|\\nabla \\phi|^2$')\n",
    "    im = ax[2].imshow(PED, aspect='auto', interpolation='none', origin='lower')   \n",
    "    ax[2].plot(np.arange(len(bubble[0][t_coleman])), np.ones(len(bubble[0][t_coleman]))*t_coleman, 'r-')\n",
    "    clb = plt.colorbar(im, ax = ax[2]); ax[2].set_title(r'PED: $V(\\phi)$'); ax[2].set(xlabel = r'$x$', ylabel=r'$t$')\n",
    "    im = ax[3].imshow(TED, aspect='auto', interpolation='none', origin='lower')   \n",
    "    ax[3].plot(np.arange(len(bubble[0][t_coleman])), np.ones(len(bubble[0][t_coleman]))*t_coleman, 'r-')\n",
    "    clb = plt.colorbar(im, ax = ax[3]); ax[3].set_title(r'TED: $\\frac{1}{2}\\left[(\\partial_t \\phi)^2 +|\\nabla \\phi|^2\\right] +V(\\phi)$'); ax[3].set(xlabel = r'$x$')\n",
    "    plt.savefig(plots_file+'energy_densities'+suffix+'.png');\n",
    "    return\n",
    "\n",
    "def plot_total_energy(bubble, bubble_mom_sq, bubble_gradient, bubble_potential):\n",
    "    KE, GE, PE, TE = bubble_total_energy(bubble, bubble_mom_sq, bubble_gradient, bubble_potential)\n",
    "    t_coleman = coleman_match(bubble[0])[0]\n",
    "\n",
    "    fig = plt.figure(figsize=(5,4))\n",
    "    plt.plot(np.arange(len(KE)), KE, 'b-', label = 'KE')\n",
    "    plt.plot(np.arange(len(GE)), GE, 'g-', label = 'GE')\n",
    "    plt.plot(np.arange(len(PE)), PE, 'y-', label = 'PE')\n",
    "    plt.plot(np.arange(len(TE)), TE, 'r-', label = 'TE', linewidth=5.0)\n",
    "    plt.axhline(np.mean(TE), color = 'darkgray', ls = '--')\n",
    "    plt.axvline(t_coleman, color = 'darkgray', ls = '--')#, label=r'$t_C$')\n",
    "    plt.xlabel('$t$'); plt.ylabel(r'$TE = \\int dx$ TED'); plt.legend()\n",
    "    plt.savefig(plots_file+'energy_balance'+suffix+'.png'); plt.show()\n",
    "    return\n",
    "\n",
    "def plot_bubble_profile(bubble, bubble_mom_sq, bubble_gradient, bubble_potential, timeslice):\n",
    "    KED, GED, PED, TED = bubble_energies(bubble, bubble_mom_sq, bubble_gradient, bubble_potential)\n",
    "    t_coleman = coleman_match(bubble[0])[0]\n",
    "    final_t = timeslice - t_coleman\n",
    "    \n",
    "    fig = plt.figure(figsize=(10,8)); plt.subplots_adjust(hspace=.0)\n",
    "    gs = gridspec.GridSpec(5, 1, height_ratios=[2, 1, 1, 1, 1])\n",
    "    ax = [[],[],[],[], []]; ax[0] = plt.subplot(gs[0])\n",
    "    ax[1] = plt.subplot(gs[1], sharex = ax[0]); ax[2] = plt.subplot(gs[2], sharex = ax[1])\n",
    "    ax[3] = plt.subplot(gs[3], sharex = ax[2]); ax[4] = plt.subplot(gs[4], sharex = ax[3])\n",
    "\n",
    "    ax[0].plot(np.arange(len(bubble[0][timeslice])), bubble[0][timeslice], 'ko', ms='3', label = 'Average Bubble at t = '+str(timeslice))\n",
    "    ax[1].plot(np.arange(len(PED[timeslice])), PED[timeslice], 'y-', label = 'PED')\n",
    "    ax[2].plot(np.arange(len(KED[timeslice])), KED[timeslice], 'b-', label = 'KED')\n",
    "    ax[3].plot(np.arange(len(GED[timeslice])), GED[timeslice], 'g-', label = 'GED')\n",
    "    ax[4].plot(np.arange(len(TED[timeslice])), TED[timeslice], 'r-', label = 'TED')\n",
    "\n",
    "    if final_t >= 0:\n",
    "        bubble_match = [i if i != 0. else None for i in coleman_bubble[final_t]]\n",
    "        first_line = coleman_bubble[final_t].tolist().index(0)\n",
    "        last_line = len(coleman_bubble[final_t]) - 1 - coleman_bubble[final_t][::-1].tolist().index(0)\n",
    "        ax[0].plot(np.arange(len(bubble_match)), bubble_match, 'r-', label = 'Coleman Bubble at t = '+str(timeslice))\n",
    "        ax[0].axvline(first_line, color = 'darkgray', ls = '--'); ax[0].axvline(last_line, color = 'darkgray', ls = '--')\n",
    "        ax[1].axvline(first_line, color = 'darkgray', ls = '--'); ax[1].axvline(last_line, color = 'darkgray', ls = '--')\n",
    "        ax[2].axvline(first_line, color = 'darkgray', ls = '--'); ax[2].axvline(last_line, color = 'darkgray', ls = '--')\n",
    "        ax[3].axvline(first_line, color = 'darkgray', ls = '--'); ax[3].axvline(last_line, color = 'darkgray', ls = '--')\n",
    "        ax[4].axvline(first_line, color = 'darkgray', ls = '--'); ax[4].axvline(last_line, color = 'darkgray', ls = '--')\n",
    "\n",
    "    ax[0].legend(); ax[1].legend(); ax[2].legend(); ax[3].legend(); ax[4].legend(); ax[4].set(xlabel='$x$')\n",
    "    plt.savefig(plots_file+'bubble_profile_at_t'+str(timeslice)+suffix+'.png'); plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "coleman_bubble_file = pickle_location+'coleman_bubble_file'+suffix+'.npy'\n",
    "#coleman_bubble = \n",
    "#np.save(coleman_bubble_file, coleman_bubble)\n",
    "\n",
    "coleman_bubble = np.load(coleman_bubble_file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "lim_bubble = 0.4\n",
    "\n",
    "bubble_cutouts = cut_out_coordinates(lim_bubble)\n",
    "ab = stack_bubbles(bubble_cutouts, 0)\n",
    "abm = stack_bubbles(bubble_cutouts, 1)\n",
    "abgsq = stack_bubbles(bubble_cutouts, 2)\n",
    "abp = stack_bubbles(bubble_cutouts, 3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "timeslice = 110\n",
    "\n",
    "plot_coleman_match(ab)\n",
    "plot_bubble_profile(ab, abm, abgsq, abp, timeslice)\n",
    "plot_total_energy_density(ab, abm, abgsq, abp)\n",
    "plot_total_energy(ab, abm, abgsq, abp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def total_energy_bubble(dr0, r0):\n",
    "    velocity = dr0 * dx / dtout # = np.sqrt( 1 - (r0/r)**2 )\n",
    "    bubble_area = 2 #0-d n-sphere     #2-d: 4.*np.pi * r**2\n",
    "    bubble_volume = 2 * r0 * dx #1-d n-ball     #3d: 4.*np.pi * r**3 / 3.\n",
    "    relativistic_factor = np.sqrt(1 - velocity**2)\n",
    "    return bubble_area * wall_tension / relativistic_factor - bubble_volume * epsilon\n",
    "\n",
    "def total_energy(bubble, bubble_mom_sq, bubble_gradient, bubble_potential, timeslice):\n",
    "    TED = bubble_energies(bubble, bubble_mom_sq, bubble_gradient, bubble_potential)[-1]\n",
    "    _, _, int_min, int_max = extract_radius(bubble[0], timeslice)\n",
    "    curve = TED[timeslice][int(round(int_min)):int(round(int_max))+1]\n",
    "    # finds first timeslice with no new phase field\n",
    "    t_no_bubble = 0\n",
    "    for t in range(len(bubble[0])):\n",
    "        true_V = 0\n",
    "        for phi in bubble[0][t]:\n",
    "            if phi > right_phi_at_V_max.x:\n",
    "                true_V += 1\n",
    "        if true_V == 0:\n",
    "            t_no_bubble = t\n",
    "            break\n",
    "    # returns total energy of bubble as:\n",
    "    # sum of TED for bubble within fwhm limits \n",
    "    # from which we subtract the energy of the false vacuum field\n",
    "    return sum(curve)# - np.mean(TED[t_no_bubble])*len(curve)\n",
    "\n",
    "def extract_radius(bubble, timeslice, sigma):\n",
    "    curve = smoothen(bubble[timeslice], sigma)\n",
    "#    curve = coleman_bubble\n",
    "    peaks, _ = signal.find_peaks(curve)\n",
    "    results_half = signal.peak_widths(curve, peaks, rel_height=0.5)\n",
    "#    plt.plot(curve); plt.plot(peaks, curve[peaks], \"x\"); plt.hlines(*results_half[1:], color=\"C2\")\n",
    "#    results_half[:] = (length of width, height, min intersection point, max intersection point)\n",
    "    width_bubble = max(results_half[0])\n",
    "    bubble_index = results_half[0].tolist().index(width_bubble)\n",
    "    return width_bubble/2., results_half[1][bubble_index], results_half[2][bubble_index], results_half[2][bubble_index]\n",
    "\n",
    "def line(x, A, B): # this is your 'straight line' y=f(x)\n",
    "    return A*x + B\n",
    "\n",
    "def field_ansatz(r, r0, dr):\n",
    "    return np.tanh( (r0 - r)/dr )*np.pi/2 + 3*np.pi/2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "t_coleman = coleman_match(ab[0])[0]\n",
    "time = t_coleman\n",
    "t_line_fit = time\n",
    "\n",
    "x = np.arange(len(ab[0]))\n",
    "y = np.arange(len(ab[0])-t_coleman)\n",
    "r0 = [extract_radius(ab[0], time)[0] for time in x]\n",
    "\n",
    "wall_tension, err = integrate.quad(lambda x: np.sqrt(2*(V(x) - V(2*np.pi))), np.pi, 2*np.pi)\n",
    "epsilon = V(np.pi) - V(2*np.pi)\n",
    "r0_th = [np.sqrt( ( 3*wall_tension/epsilon )**2 + ( dtout*t/dx )**2 ) for t in y]\n",
    "wall_thkn = right_phi_at_V_max.x / np.sqrt( V(right_phi_at_V_max.x) - V(np.pi) )\n",
    "\n",
    "plt.plot(x, [total_energy(ab, abm, abgsq, abp, t) for t in x], 'g')\n",
    "plt.plot(x, [total_energy_bubble(r0[i]-r0[i-1], r0[i]) for i in x], 'ro')\n",
    "plt.plot(y+t_coleman, [total_energy_bubble(r0_th[i]-r0_th[i-1], r0_th[i]) for i in y], 'b')\n",
    "plt.axvline(t_coleman, color='darkgray', ls='--')\n",
    "plt.axhline(0, color='darkgray', ls='--')\n",
    "plt.ylim((-1,10))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_timeslice_tanh_fit(bubble, timeslice):\n",
    "    best_tanh, covs = sco.curve_fit(field_ansatz, np.arange(nLat//2), bubble[timeslice][nLat//2:])\n",
    "    plt.figure()\n",
    "    plt.plot(np.arange(nLat//2), bubble[timeslice][nLat//2:], 'ro', ms=3, label='data')\n",
    "    plt.plot(np.arange(nLat//2), [field_ansatz(r, best_tanh[0], best_tanh[1]) for r in np.arange(nLat//2)], label=r'$\\tanh\\left(\\frac{r - r_0}{\\delta}\\right)$')\n",
    "    plt.ylabel(r'$\\phi(x)$'); plt.xlabel('t'); plt.legend(); plt.show()\n",
    "    return\n",
    "\n",
    "def plot_bubble_tanh_fit_params(bubble):\n",
    "    t_coleman = coleman_match(bubble)[0]\n",
    "    x = np.arange(len(bubble))\n",
    "    y = np.arange(len(bubble)-t_coleman)\n",
    "    r0 = [extract_radius(bubble, timeslice)[0] for timeslice in x]\n",
    "    best_tanh = [sco.curve_fit(field_ansatz, np.arange(nLat//2), bubble[time][nLat//2:]) for time in x]\n",
    "    r0_th = [np.sqrt( ( 3*wall_tension/epsilon )**2 + ( dtout*t/dx )**2 ) for t in y]\n",
    "    wall_thkn = right_phi_at_V_max.x / np.sqrt( V(right_phi_at_V_max.x) - V(np.pi) )\n",
    "\n",
    "    fig = plt.figure(figsize=(14,5)); gs = gridspec.GridSpec(1, 2); ax = [[],[]]\n",
    "    ax[0] = plt.subplot(gs[0]); ax[1] = plt.subplot(gs[1])\n",
    "    ax[0].plot(x, r0, 'b-', label = 'fwhm')\n",
    "    ax[0].plot(y+t_coleman, r0_th, color='yellow', ls = '-', label = r'$\\rho=3\\sigma/\\epsilon$')\n",
    "    ax[0].plot(x, [best_tanh[timeslice][0][0] for timeslice in x], 'g-', label='best fit')\n",
    "    ax[0].plot(y+t_coleman, y*dtout/dx, color = 'darkgray', ls='--')\n",
    "    ax[0].axvline(t_coleman, color='darkgray', ls='--')\n",
    "    ax[0].set(xlabel='t', ylabel='x'); ax[0].legend()\n",
    "\n",
    "    ax[1].plot(x, [best_tanh[timeslice][0][1] for timeslice in x], 'g-')\n",
    "    ax[1].axvline(t_coleman, color='darkgray', ls='--')\n",
    "    ax[1].axhline(wall_thkn, color='yellow', ls='-', label=r'$\\phi_m/\\sqrt{V_m-V_{fv}}$')\n",
    "    ax[1].set(xlabel='t', ylabel='x'); ax[1].legend()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plot_timeslice_tanh_fit(ab[0], 200)\n",
    "plot_bubble_tanh_fit_params(ab[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.7 (conda) - recommended",
   "language": "python",
   "name": "python37-conda"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
