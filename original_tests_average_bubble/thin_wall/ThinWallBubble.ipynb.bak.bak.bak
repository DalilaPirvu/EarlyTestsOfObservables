{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Bubble Correlations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import math\n",
    "import sep\n",
    "import operator\n",
    "import matplotlib\n",
    "from matplotlib import gridspec; \n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.ticker as ticker\n",
    "import scipy\n",
    "import scipy.signal as scs\n",
    "import scipy.special as ssp\n",
    "from scipy.integrate import odeint\n",
    "from scipy.stats import shapiro, normaltest, anderson\n",
    "import random\n",
    "import statistics as stat\n",
    "import operator\n",
    "from itertools import zip_longest\n",
    "from collections import OrderedDict\n",
    "from labellines import labelLine, labelLines\n",
    "from celluloid import Camera"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Simulation Parameters "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lamb =  5.799999999999999\n",
      "m2eff =  0.2611199999999999\n",
      "lenLat =  395.28470752104744\n",
      "phi0 =  0.7853981633974483\n"
     ]
    }
   ],
   "source": [
    "nLat = 1000\n",
    "nTime = 500\n",
    "nSims = 30\n",
    "\n",
    "nu = 2.*10**(-3)\n",
    "omega = 0.25 * 50. * 2. * np.sqrt(nu)\n",
    "delt = np.sqrt(nu / 2.) * (5. + 0.8); \n",
    "rho = 200. * 2. * np.sqrt(nu) / 2.**3\n",
    "lamb = delt * np.sqrt(2. / nu); print('lamb = ', lamb)\n",
    "m2eff = 4. * nu * (- 1. + lamb**2); print('m2eff = ', m2eff)\n",
    "lenLat = 0.5 * 50. / np.sqrt(2. * nu); print('lenLat = ', lenLat)\n",
    "\n",
    "alpha = 8.\n",
    "nCols = 4\n",
    "n_cross = 2\n",
    "phi0 = 2 * np.pi / 8; print('phi0 = ', phi0)\n",
    "phi_initial = np.pi\n",
    "dt_phi_initial = 0.\n",
    "\n",
    "############################################################\n",
    "nyq = nLat//2+1\n",
    "spec = nyq//2\n",
    "hLat = nLat//2\n",
    "dx = lenLat/nLat\n",
    "dk = 2.*np.pi/lenLat\n",
    "dt = dx/alpha\n",
    "outsize = 4*n_cross*nLat/nTime\n",
    "dtout = dt*outsize\n",
    "\n",
    "paper_norm = 1./ phi0 / np.sqrt(4*lenLat)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[5.93662603]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 360x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "def V(phi): \n",
    "    return ( -np.cos(phi) + 0.5 * lamb**2 * np.sin(phi)**2 ) * 4 * nu\n",
    "def dV(phi):\n",
    "    return ( np.sin(phi) + 0.5 * lamb**2 * np.sin(2*phi) ) * 4 * nu\n",
    "\n",
    "right_phi_at_V_max = scipy.optimize.minimize_scalar(lambda x: -V(x), bounds=[np.pi, 2*np.pi], method='bounded')\n",
    "left_phi_at_V_max = scipy.optimize.minimize_scalar(lambda x: -V(x), bounds=[0, np.pi], method='bounded')\n",
    "\n",
    "def F(x):\n",
    "    return V(x) - V(np.pi)\n",
    "phi_bound = scipy.optimize.fsolve(F, 5.5)\n",
    "print(phi_bound)\n",
    "\n",
    "matplotlib.rcParams.update({'font.size': 12})\n",
    "fig = plt.figure(figsize=(5,4))\n",
    "plt.plot([i for i in np.arange(0, 2*np.pi, np.pi/100)], [V(i) for i in np.arange(0, 2*np.pi, np.pi/100)])\n",
    "plt.plot(phi_bound, V(phi_bound), 'ro')\n",
    "plt.axvline(left_phi_at_V_max.x, color='y', ls='--'); plt.axvline(right_phi_at_V_max.x, color='y', ls='--')\n",
    "plt.xlabel(r'$\\phi(x)$'); plt.ylabel(r'$V(\\phi(x))$'); plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "#recombination_time = [time for time in range(nTime) if time%(1/(dtout*np.sqrt(m2eff)))==0]\n",
    "titles = [r'$\\phi(x)$', r'$\\partial_t \\phi(x)$', r'$|\\nabla \\phi(x)|^2$', r'$V(\\phi(x))$']\n",
    "plots_file = '/home/dpirvu/bubble_analysis_thin_wall/plots/'\n",
    "pickle_location = '/home/dpirvu/bubble_analysis_thin_wall/data_save/'\n",
    "suffix = '_for_lamb{:.1f}'.format(lamb)+'_t'+str(nTime)+'_x'+str(nLat)\n",
    "\n",
    "def sim_location(sim):\n",
    "    return '/gpfs/dpirvu/bubble_correlations/lamb{:.1f}'.format(lamb)+'_t'+str(nTime)+'_x'+str(nLat)+'_sim'+str(sim)+'_fields.dat'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Extract data from files"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def extract_data(filename, col):\n",
    "    infile = open(filename,'r')\n",
    "    lines = infile.readlines()\n",
    "    field_values = [float(line.split()[col]) for line in lines[1:]]\n",
    "    infile.close()\n",
    "    return field_values\n",
    "\n",
    "def all_real_space_data():\n",
    "    all_rsp_data = []\n",
    "    for sim in range(nSims):\n",
    "        if sim == nSims // 2:\n",
    "            print('Halfway through.')\n",
    "#        print('sim: ', sim, ' ongoing')\n",
    "        sims_tableau = []\n",
    "        for col in range(nCols):\n",
    "            simulation = extract_data(sim_location(sim), col)\n",
    "            simulation = np.reshape(simulation,(nTime, nLat))\n",
    "            sims_tableau.append(simulation)\n",
    "        all_rsp_data.append(sims_tableau)\n",
    "    return(all_rsp_data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Halfway through.\n",
      "(30, 4, 500, 1000)\n"
     ]
    }
   ],
   "source": [
    "all_real_data = all_real_space_data()\n",
    "print(np.shape(all_real_data))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2  +  1  +  25  +  2  =  30\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "all_non_decaying_sims, all_right_decaying_sims, all_left_decaying_sims, all_doubly_decaying_sims = [], [], [], []\n",
    "\n",
    "for sim in range(nSims):\n",
    "    final_timeslice = all_real_data[sim][0][-1]\n",
    "    left_phi_x, right_phi_x = 0, 0\n",
    "    for phi_x in final_timeslice:\n",
    "        if phi_x >= phi_initial + np.pi/2:\n",
    "            right_phi_x += 1\n",
    "        if phi_x <= phi_initial - np.pi/2:\n",
    "            left_phi_x += 1\n",
    "    if (left_phi_x < nLat*0.06 and right_phi_x > nLat*0.06):\n",
    "        boolean = False\n",
    "        for t in range(nTime):\n",
    "            if boolean:\n",
    "                break\n",
    "            if t != nTime-1:\n",
    "                left_phi_x_prime = 0\n",
    "                for phi_x_prime in all_real_data[sim][0][t]:\n",
    "                    if phi_x_prime <= phi_initial - np.pi/2:\n",
    "                        left_phi_x_prime += 1\n",
    "                if left_phi_x_prime >= nLat*0.06:\n",
    "                    all_doubly_decaying_sims.append(sim)\n",
    "                    boolean = True\n",
    "            else:\n",
    "                all_right_decaying_sims.append(sim)\n",
    "    elif (left_phi_x > nLat*0.06 and right_phi_x < nLat*0.06):\n",
    "        boolean = False\n",
    "        for t in range(nTime):\n",
    "            if boolean:\n",
    "                break\n",
    "            if t != nTime-1:\n",
    "                right_phi_x_prime = 0\n",
    "                for phi_x_prime in all_real_data[sim][0][t]:\n",
    "                    if phi_x_prime >= phi_initial + np.pi/2:\n",
    "                        right_phi_x_prime += 1\n",
    "                if right_phi_x_prime >= nLat*0.06:\n",
    "                    all_doubly_decaying_sims.append(sim)\n",
    "                    boolean = True\n",
    "            else:\n",
    "                all_left_decaying_sims.append(sim)\n",
    "    elif (left_phi_x < nLat*0.06 and right_phi_x < nLat*0.06):\n",
    "        all_non_decaying_sims.append(sim)\n",
    "    elif (left_phi_x > nLat*0.06 and right_phi_x > nLat*0.06):\n",
    "        all_doubly_decaying_sims.append(sim)\n",
    "        \n",
    "print(str(len(all_right_decaying_sims)),' + ',str(len(all_left_decaying_sims)),' + ',str(len(all_non_decaying_sims)),' + ',str(len(all_doubly_decaying_sims)),' = ',str(nSims))\n",
    "len(all_right_decaying_sims)+len(all_left_decaying_sims)+len(all_non_decaying_sims)+len(all_doubly_decaying_sims) == nSims"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## VISUALISING SIMULATION DATA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def masked_field_slice(field_slice, threshold):\n",
    "    mask = [1 if phi_x >= threshold else 0 for phi_x in field_slice]\n",
    "    masked_field_slice = mask*field_slice\n",
    "    return masked_field_slice, np.count_nonzero(masked_field_slice)\n",
    "\n",
    "def plot_real_space_data(sim, col):\n",
    "    simulation = all_real_data[sim][col]\n",
    "    fig, ax = plt.subplots(1, figsize=(5,4))\n",
    "#    pspec = [[abs(i*np.conj(i)) for i in field_slice] for field_slice in simulation]\n",
    "    im = ax.imshow(simulation, aspect='auto', interpolation='none', origin='lower', extent=[0, dx*nLat, 0, dtout*nTime])\n",
    "    clb = plt.colorbar(im, ax = ax)\n",
    "    ax.set(xlabel = r'$x$', ylabel = r'$t$')\n",
    "    plt.show()\n",
    "    return\n",
    "\n",
    "def plot_real_space_slices(sim, col, i, j, steps, max):\n",
    "    plt.figure(figsize=(20, 5))\n",
    "    simulation = all_real_data[sim][col][i:j:steps]\n",
    "    for field_slice in simulation:\n",
    "        plt.plot(np.arange(max), field_slice[:max], label = i)\n",
    "#    pspec = [[abs(i*np.conj(i)) for i in field_slice] for field_slice in simulation]\n",
    "#    for slice in pspec[i:j:steps]:\n",
    "#        plt.plot(np.arange(1, max), slice[1:max], label = i)\n",
    "        i = i + steps\n",
    "    labelLines(plt.gca().get_lines(), xvals=(0, max), align=False)\n",
    "    plt.xlabel(r'$x$')\n",
    "    plt.grid()\n",
    "    plt.show()\n",
    "    return\n",
    "\n",
    "def add_mask(field_slice, threshold):\n",
    "    mask = [0 if -threshold <= field_slice[i] <= threshold else 1 for i in range(len(field_slice))]\n",
    "    return field_slice * mask\n",
    "\n",
    "def make_mask(simulation, threshold):\n",
    "    mask = np.ones((nTime, nLat))\n",
    "    for j in range(nTime):\n",
    "        for i in range(nLat):\n",
    "            if -threshold <= simulation[j, i] <= threshold:\n",
    "                mask[j, i] = 0\n",
    "    return mask\n",
    "\n",
    "def plot_masked_field(simulation, threshold):\n",
    "    fig, ax = plt.subplots(figsize=(5,4))\n",
    "    masked_field = [add_mask(field_slice, threshold) for field_slice in simulation]\n",
    "    im = ax.imshow(masked_field, aspect='auto', interpolation='none', origin='lower')#, extent=[0, dx*nLat, 0, dtout*nTime]) \n",
    "    clb = plt.colorbar(im, ax = ax)\n",
    "    ax.set(xlabel = r'$x$', ylabel=r'$t$')\n",
    "    plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "#for sim in all_right_decaying_sims:\n",
    "#    col = 0\n",
    "#    plot_real_space_data(sim, col)\n",
    "#    plot_real_space_slices(sim, col, 0, 100, 50, nLat)    #(sim, i, j, steps, max)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Power Spectrum"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "field_spectrum = [paper_norm / ((dk*k)**2 + m2eff)**0.25 for k in range(nyq)]\n",
    "phi_x = np.fft.irfft(field_spectrum, nLat) + phi_initial\n",
    "phi_k = np.fft.rfft(phi_x, nLat)\n",
    "\n",
    "momentum_spectrum = [paper_norm * ((dk*k)**2 + m2eff)**0.25 for k in range(nyq)]\n",
    "dt_phi_x = np.fft.irfft(momentum_spectrum, nLat) + dt_phi_initial\n",
    "dt_phi_k = np.fft.rfft(dt_phi_x, nLat)\n",
    "\n",
    "def power_spectrum(col, k):\n",
    "    if col == 0:\n",
    "        return phi_k[k] * np.conj(phi_k[k])\n",
    "    elif col == 1:\n",
    "        return dt_phi_k[k] * np.conj(dt_phi_k[k])\n",
    "    \n",
    "def data_pspec_from_rspec(col, sim, k):\n",
    "    timeslice = random.randrange(nTime)\n",
    "    field_slice = all_real_data[sim][col][timeslice]\n",
    "    fft_field_slice = np.fft.irfft(field_slice, nLat)\n",
    "    return fft_field_slice[k] * np.conj(fft_field_slice[k])\n",
    "\n",
    "def data_pspec_from_rspec_sim_averaged(col, k):\n",
    "    return np.mean([data_pspec_from_rspec(col, sim, k).real for sim in all_non_decaying_sims])\n",
    "\n",
    "def power_spectrum_theoretical_vs_data(col):\n",
    "    plt.figure(figsize=(7, 5))\n",
    "    plt.plot(dk*np.arange(1, spec), [data_pspec_from_rspec_sim_averaged(col, k) for k in range(1, spec)], 'go')\n",
    "    plt.plot(dk*np.arange(1, spec), [power_spectrum(col, k).real for k in range(1, spec)], 'r--')\n",
    "    plt.xlabel(r'$k$'); plt.ylabel(r'Power Spectrum'); plt.grid(); plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 504x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "#To compare with case of free Gaussian field, select simulations which do not decay. \n",
    "#If need to use the rest, consider only part of simulations before bubble forms\n",
    "\n",
    "power_spectrum_theoretical_vs_data(0)\n",
    "\n",
    "# Free field approximation not true at low separation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Peak-Peak Correlator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def data_stat(sim_selection, smoothing_scale):\n",
    "    data = [smoothen(all_real_data[sim][0][random.randrange(nTime)], smoothing_scale)[random.randrange(nLat)] for sim in sim_selection]\n",
    "    return stat.stdev(data), np.mean(data)\n",
    "\n",
    "def find_peak_positions(field_slice, peak_threshold):\n",
    "    \"\"\" Finds x coordinate of peaks in masked field with mask applied at threshold. \"\"\"\n",
    "    peak_coord = scs.find_peaks(field_slice, height = peak_threshold)[0].tolist()\n",
    "    if field_slice[-1] > peak_threshold and field_slice[0] > peak_threshold and field_slice[-1] != field_slice[0]:\n",
    "        if field_slice[0] > field_slice[-1] and field_slice[0] > field_slice[1]:\n",
    "            peak_coord.append(0)\n",
    "        elif field_slice[0] < field_slice[-1] and field_slice[-1] > field_slice[-2]:\n",
    "            peak_coord.append(len(field_slice)-1) # this minds potential boundary discontinuities\n",
    "    return peak_coord\n",
    "\n",
    "def find_max_peak(field_slice):\n",
    "    peak_coord = scs.find_peaks(field_slice)[0].tolist()\n",
    "    if field_slice[0] > field_slice[-1] and field_slice[0] > field_slice[1]:\n",
    "        peak_coord.append(0)\n",
    "    if field_slice[-1] > field_slice[0] and field_slice[-1] > field_slice[-2]:\n",
    "        peak_coord.append(len(field_slice)-1)\n",
    "    peak_heights = [field_slice[coord] for coord in peak_coord]\n",
    "    return field_slice.tolist().index(np.max(peak_heights)), np.max(peak_heights), peak_coord, peak_heights\n",
    "\n",
    "def smoothen(field_slice, sigma):\n",
    "    pbc = [j-1 if j < nLat/2+1 else nLat-j+1 for j in range(1, nLat+1)]\n",
    "    window = [np.exp(- 0.5 * (i*dx/sigma)**2) / np.sqrt(2*np.pi) / sigma for i in pbc]\n",
    "    real_filter = np.fft.rfft(window / sum(window), len(field_slice))\n",
    "\n",
    "    fft_field_slice = np.fft.rfft(field_slice, len(field_slice))\n",
    "    smooth_fft_field_slice = [real_filter[k] * fft_field_slice[k] for k in range(len(fft_field_slice))]\n",
    "    return np.fft.irfft(smooth_fft_field_slice, len(field_slice))\n",
    "\n",
    "def nu2phi(x):\n",
    "    return x*moment0+phi_initial\n",
    "def phi2nu(x):\n",
    "    return (x-phi_initial)/moment0\n",
    "\n",
    "def peak_number_density_est(sim_selection, smoothing_scale, peak_threshold):\n",
    "    all_field_slices = [all_real_data[sim][0][random.randrange(nTime)] for sim in sim_selection]\n",
    "    smooth_field_slice = [smoothen(slice, smoothing_scale) for slice in all_field_slices]\n",
    "    peak_coordinates = [find_peak_positions(field_slice, peak_threshold) for field_slice in smooth_field_slice]\n",
    "    N_gal = sum([len(coords) for coords in peak_coordinates])\n",
    "    return N_gal / len(smooth_field_slice[0]) / len(sim_selection)\n",
    "\n",
    "def analytic_peak_number_density(peak_threshold_nu):\n",
    "    thr = peak_threshold_nu\n",
    "    return 0.158979+np.exp(-0.5*thr**2)*(0.0643448+0.0643448*ssp.erf(0.312973*thr))-0.158979*ssp.erf(0.773274*thr)\n",
    "\n",
    "def correlators(sim_selection, smoothing_scale, th, R):\n",
    "    r_correlator = 0.\n",
    "    for sim in sim_selection:\n",
    "        t = random.randrange(nTime)\n",
    "        field_slice = smoothen(all_real_data[sim][0][t], smoothing_scale)\n",
    "        peak_coordinates = find_peak_positions(field_slice, th)\n",
    "        N_gal = len(peak_coordinates)\n",
    "        if N_gal != 0:\n",
    "            peak_list = [i-nLat if i >= nLat else i for i in np.asarray(peak_coordinates)+R]\n",
    "            rivolo_check = sum([1. for i in peak_list if i in peak_coordinates])\n",
    "            r_correlator += rivolo_check * len(field_slice) / N_gal**2\n",
    "    return r_correlator / len(sim_selection) - 1.\n",
    "\n",
    "max_sep = 100\n",
    "gaussian_filter = 1. / (dk * spec / 2.)\n",
    "sim_selection = all_non_decaying_sims[::]\n",
    "moment0 = data_stat(sim_selection, gaussian_filter)[0]\n",
    "\n",
    "#outfile05 = pickle_location+'peak_th05'+suffix+'.npy'\n",
    "#np.save(outfile05, [correlators(sim_selection, gaussian_filter, 0.5*moment0 + phi_initial, R) for R in range(1, max_sep, 1)])\n",
    "\n",
    "#outfile1 = pickle_location+'peak_th1'+suffix+'.npy'\n",
    "#np.save(outfile1, [correlators(sim_selection, gaussian_filter, 1*moment0 + phi_initial, R) for R in range(1, max_sep, 1)])\n",
    "\n",
    "#outfile2 = pickle_location+'peak_th2'+suffix+'.npy'\n",
    "#np.save(outfile2, [correlators(sim_selection, gaussian_filter, 2*moment0 + phi_initial, R) for R in range(1, max_sep, 1)])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_peak_number_density(sim_selection, smoothing_scale):\n",
    "    moment0 = data_stat(sim_selection, smoothing_scale)[0]\n",
    "    nu = math.ceil(phi2nu(2*np.pi))\n",
    "    th = [i/4. for i in range(4*nu+1)]\n",
    "    data = [peak_number_density_est(sim_selection, smoothing_scale, nu2phi(i)) for i in th]\n",
    "    thr = [i/100. for i in range(100*nu+1)]\n",
    "    prediction = [analytic_peak_number_density(i)*dx for i in thr]\n",
    "\n",
    "    fig, ax = plt.subplots(figsize=(8,4))\n",
    "    ax.plot(thr, prediction, color='y', ls='--', label='Peak number density')\n",
    "    ax.plot(th, data, 'bo', label='Data')\n",
    "    ax.axvline(phi2nu(right_phi_at_V_max.x))\n",
    "    ax.axvline(phi2nu(np.pi), color = 'y', ls = '-')\n",
    "    ax.axvline(phi2nu(2*np.pi), color = 'y', ls = '-')\n",
    "    secax = ax.secondary_xaxis('top', functions=(nu2phi, phi2nu))\n",
    "    secax.set_xlabel(r'$\\phi$'); plt.xlabel(r'$\\nu_t$'); plt.ylabel(r'$n(\\nu_t)$')\n",
    "    plt.legend(); plt.grid(); plt.show()\n",
    "    return\n",
    "\n",
    "def plot_peak_peak_correlator(max_sep):\n",
    "    plt.figure(figsize=(7, 5))\n",
    "    rivolo_correlator = np.load(outfile05)[:max_sep]\n",
    "    plt.plot([i*dx for i in range(1, len(rivolo_correlator)+1)], rivolo_correlator, 'ro', label=r'$\\nu_t = 0.5$')\n",
    "    rivolo_correlator = np.load(outfile1)[:max_sep]\n",
    "    plt.plot([i*dx for i in range(1, len(rivolo_correlator)+1)], rivolo_correlator, 'go', label=r'$\\nu_t = 1$')\n",
    "    rivolo_correlator = np.load(outfile2)[:max_sep]\n",
    "    plt.plot([i*dx for i in range(1, len(rivolo_correlator)+1)], rivolo_correlator, 'bo', label=r'$\\nu_t = 2$')\n",
    "    plt.xlabel(r'$r$'); plt.ylabel(r'$\\xi_{pk}(r)$')\n",
    "    plt.grid(); plt.legend(); plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    ". It is not a bad estimate to start looking for bubbles at turning point in potential, since that is only at 2 std in peak height\n",
    "\n",
    ". Out of the total number of peaks at 2 and above std, which is obtainable from data, how many end up as bubbles? Simply count bubbles and divide by total number\n",
    "\n",
    ". Can count bubbles by looking for signature which we compute in the rest of this Notebook. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "#plot_peak_number_density(sim_selection, gaussian_filter)\n",
    "#plot_peak_peak_correlator(max_sep)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Triage"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "def time_limits_of_bubble(sim, bubble_limit):\n",
    "    filter_size = 1 / (dk * 5)\n",
    "    simulation = all_real_data[sim][0]\n",
    "    for t in range(len(simulation)):\n",
    "        right_phi_x = 0.\n",
    "        field_slice = smoothen(simulation[t], filter_size)\n",
    "        for phi_x in field_slice:\n",
    "            if phi_x >= right_phi_at_V_max.x: #2*phi_initial:\n",
    "                right_phi_x += 1.\n",
    "        if (t == nTime-1 or right_phi_x >= nLat * bubble_limit):\n",
    "            t_max = t\n",
    "            t_min = t_max - bubble_limit * nTime\n",
    "            if t_min < 0: t_min = 0\n",
    "            return int(t_min), int(t_max)\n",
    "\n",
    "def time_of_bubble_start(sim, bubble_limit):\n",
    "    t_max = time_limits_of_bubble(sim, bubble_limit)[-1]\n",
    "    list = []\n",
    "    filter_size = 1 / (dk * 10)\n",
    "    simulation = all_real_data[sim][0]\n",
    "    for t in range(t_max):\n",
    "        right_phi_x = 0.\n",
    "        field_slice = smoothen(simulation[t], filter_size)\n",
    "        for phi_x in field_slice:\n",
    "            if phi_x >= right_phi_at_V_max.x:\n",
    "                right_phi_x += 1.\n",
    "        if right_phi_x <= nLat * 0.0025:\n",
    "            list.append(t)\n",
    "        else:\n",
    "            list.append(0)\n",
    "    return max(list)\n",
    "\n",
    "def triage1(sim_selection):\n",
    "    print('Before: ', len(sim_selection))\n",
    "    for sim in sim_selection:\n",
    "        simulation = all_real_data[sim][0]\n",
    "        filter_size = 1. / ( dk * 5. )\n",
    "        light_cone = filter_size * dtout / dx # distance travelled by light in x axis within one time step\n",
    "        coords = np.empty((nTime, 0)).tolist()\n",
    "        for t in range(nTime):\n",
    "            field_slice = smoothen(simulation[t].tolist(), filter_size)\n",
    "            coords[t] = [x for x in range(nLat) if field_slice[x] >= 1.8 * phi_initial]\n",
    "            if (t > 0 and len(coords[t]) > 1 and len(coords[t-1]) > 1):\n",
    "                if (max(coords[t]) > max(coords[t-1]) + light_cone or min(coords[t]) < min(coords[t-1]) - light_cone):\n",
    "                    if not (max(coords[t]) == nLat-1 and min(coords[t]) == 0):\n",
    "                        sim_selection.remove(sim)\n",
    "    print('After: ', len(sim_selection))\n",
    "    return sim_selection\n",
    "\n",
    "def triage2(sim_selection):\n",
    "    print('Before: ', len(sim_selection))\n",
    "    filter_size = 1. / ( dk * 5. )\n",
    "    bubble_limit = 0.2\n",
    "    for sim in sim_selection:\n",
    "        t_min, t_max = time_limits_of_bubble(sim, bubble_limit)\n",
    "        if t_max != nTime-1:\n",
    "            peak_list = []\n",
    "            for t in np.arange(t_min, t_max+1):\n",
    "                field_slice = smoothen(all_real_data[sim][0][t], filter_size)\n",
    "                bubble_position_at_t = [x for x in range(len(field_slice)) if field_slice[x] > 1.8*phi_initial]\n",
    "                if len(bubble_position_at_t) > 0:\n",
    "                    peak_list.append(int(np.mean(bubble_position_at_t)))\n",
    "            if peak_list != []:\n",
    "                if stat.stdev(peak_list) < nLat*0.025:\n",
    "                    sim_selection.remove(sim)\n",
    "    print('After: ', len(sim_selection))\n",
    "    return sim_selection\n",
    "\n",
    "simsel0 = all_right_decaying_sims[::]\n",
    "simsel = simsel0\n",
    "#simsel = triage1(simsel0)\n",
    "#simsel = triage2(simsel0)\n",
    "\n",
    "#for sim in simsel:\n",
    "#    simulation = [smoothen(all_real_data[sim][0][t], 1. / ( dk * 5. )) for t in range(nTime)]\n",
    "#    plot_masked_field(simulation, right_phi_at_V_max.x)\n",
    "    \n",
    "#for sim in all_right_decaying_sims:\n",
    "#    if sim not in simsel1:\n",
    "#        simulation = [smoothen(all_real_data[sim][0][t], 1. / ( dk * 5. )) for t in range(nTime)]\n",
    "#        plot_masked_field(simulation, right_phi_at_V_max.x)\n",
    "\n",
    "#for sim in all_right_decaying_sims:\n",
    "#    if sim not in simsel2:\n",
    "#        simulation = [smoothen(all_real_data[sim][0][t], 1. / ( dk * 5. )) for t in range(nTime)]\n",
    "#        plot_masked_field(simulation, right_phi_at_V_max.x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Tracking Bubble "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_chosen_field_slices(sim, sigma, t_min, t_max):\n",
    "    fig = plt.figure(figsize=(20,4))\n",
    "    gs = gridspec.GridSpec(1, 2) \n",
    "    ax = [[],[]]\n",
    "    ax[0] = plt.subplot(gs[0])\n",
    "    ax[1] = plt.subplot(gs[1])\n",
    "\n",
    "    field_simulation = all_real_data[sim][0]\n",
    "    signal = np.asarray(field_simulation[t_min])\n",
    "    clean_signal = smoothen(signal, sigma)\n",
    "    noise = signal - clean_signal\n",
    "\n",
    "    ax[0].plot(np.arange(nLat), signal)\n",
    "    ax[0].plot(np.arange(nLat), clean_signal,'r', label='t = '+str(t_min))\n",
    "    ax[0].plot(np.arange(nLat), noise,'g.')\n",
    "    ax[0].legend(); ax[0].grid()\n",
    "\n",
    "    signal = np.asarray(field_simulation[t_max])\n",
    "    clean_signal = smoothen(field_simulation[t_max], sigma)\n",
    "    noise = signal - clean_signal\n",
    "\n",
    "    ax[1].plot(np.arange(nLat), signal)\n",
    "    ax[1].plot(np.arange(nLat), clean_signal,'r', label='t = '+str(t_max))\n",
    "    ax[1].plot(np.arange(nLat), noise,'g.')\n",
    "    ax[1].legend(); ax[1].grid(); plt.show()\n",
    "    return\n",
    "\n",
    "def plot_slice(field_slice, sigma):\n",
    "    plt.figure(figsize=(10,5))\n",
    "    plt.plot(np.arange(len(field_slice)), field_slice)\n",
    "    field_slice_sm = smoothen(field_slice, sigma)\n",
    "    plt.plot(np.arange(len(field_slice_sm)), field_slice_sm, 'b-')\n",
    "    coord, height, _, _ = find_max_peak(field_slice_sm)\n",
    "    plt.plot(coord, height, 'bo', label = 'max = {:.2f}'.format(height))\n",
    "    plt.xlabel(r'$x$'); plt.grid(); plt.legend(); plt.show()\n",
    "    return\n",
    "\n",
    "def plot_simulation(sim, sigma, t_min, t_max):\n",
    "    simulation = all_real_data[sim][0]\n",
    "    fig, ax = plt.subplots(1, 2, figsize = (5 * 2, 4), sharey = 'row')\n",
    "    im = ax[0].imshow(simulation, aspect='auto', interpolation='none', origin='lower') #, extent=[0, dx*nLat, 0, dtout*nTime])\n",
    "    ax[0].plot(np.arange(len(simulation[0])), np.ones(len(simulation[0]))*t_min, 'r-')\n",
    "    ax[0].plot(np.arange(len(simulation[0])), np.ones(len(simulation[0]))*t_max, 'y-')\n",
    "    clb = plt.colorbar(im, ax = ax[0])\n",
    "    clb.set_label(r'$\\phi$', labelpad=-48, y=1.08, rotation=0)\n",
    "    ax[0].set(xlabel = r'$x$', ylabel = r'$t$')\n",
    "\n",
    "    im = ax[1].imshow([smoothen(field_slice, sigma) for field_slice in simulation], aspect='auto', interpolation='none', origin='lower')#, extent=[0, dx*nLat, 0, dtout*nTime])\n",
    "    ax[1].plot(np.arange(len(simulation[0])), np.ones(len(simulation[0]))*t_min, 'r-')\n",
    "    ax[1].plot(np.arange(len(simulation[0])), np.ones(len(simulation[0]))*t_max, 'y-')\n",
    "    clb = plt.colorbar(im, ax = ax[1])\n",
    "    clb.set_label(r'$\\phi$', labelpad=-28, y=1.08, rotation=0)\n",
    "    ax[1].set(xlabel = r'$x$', ylabel = r'$t$')\n",
    "    plt.show()\n",
    "    return\n",
    "\n",
    "def plot_field_and_momentum_slice(sim, sigma, time):\n",
    "    fig = plt.figure(figsize=(20,4))\n",
    "    gs = gridspec.GridSpec(1, 2); ax = [[],[]]\n",
    "    ax[0] = plt.subplot(gs[0]); ax[1] = plt.subplot(gs[1])\n",
    "    \n",
    "    field_slice = all_real_data[sim][0][time]\n",
    "    momentum_slice = all_real_data[sim][1][time]\n",
    "    ax[0].plot(dx*np.arange(len(field_slice)), field_slice, 'k-')\n",
    "    field_slice_sm = smoothen(field_slice, sigma)\n",
    "    ax[0].plot(dx*np.arange(len(field_slice_sm)), field_slice_sm, 'b-')\n",
    "    coord, height, _, _ = find_max_peak(field_slice_sm)\n",
    "    ax[0].plot(dx*coord, height, 'bo', label = 'max = {:.2f}'.format(height))\n",
    "    ax[0].set(xlabel=r'$x$'); ax[0].grid(); ax[0].legend()\n",
    "\n",
    "    ax[1].plot(dx*np.arange(len(momentum_slice)), momentum_slice, 'k-')\n",
    "    momentum_slice_sm = smoothen(momentum_slice, sigma)\n",
    "    ax[1].plot(dx*np.arange(len(momentum_slice_sm)), momentum_slice_sm, 'b-')\n",
    "    min_momentum = np.min(np.abs(momentum_slice_sm))\n",
    "    coord_min = np.abs(momentum_slice_sm).tolist().index(min_momentum)\n",
    "    coord_max, max_momentum, _, _ = find_max_peak(momentum_slice_sm)\n",
    "    ax[1].plot(dx*coord_max, max_momentum, 'bo', label = 'max = {:.4f}'.format(max_momentum))\n",
    "    ax[1].set(xlabel=r'$x$'); ax[1].grid(); ax[1].legend(); plt.show()\n",
    "    return\n",
    "\n",
    "def plot_max_trajectory(sim, sigma, t_min, t_max):\n",
    "    fig = plt.figure(figsize=(20,4))\n",
    "    gs = gridspec.GridSpec(1, 2); ax = [[],[]]\n",
    "    ax[0] = plt.subplot(gs[0]); ax[1] = plt.subplot(gs[1])\n",
    "    time_list = np.arange(t_min, t_max+1).tolist()\n",
    "\n",
    "    col = 0\n",
    "    simulation = [all_real_data[sim][col][t] for t in time_list]\n",
    "    smooth_simulation = [smoothen(field_slice, sigma) for field_slice in simulation]\n",
    "    simulation_peak_stats = [find_max_peak(smooth_field_slice) for smooth_field_slice in smooth_simulation]\n",
    "    bubble_trajectory = [slice_peak_stats[0] for slice_peak_stats in simulation_peak_stats]\n",
    "    bubble_height = [slice_peak_stats[1] for slice_peak_stats in simulation_peak_stats]\n",
    "\n",
    "    ax[0].plot(dx*np.asarray(bubble_trajectory), bubble_height, 'ko-', ms=3)\n",
    "    ax[0].plot(dx*bubble_trajectory[0], bubble_height[0], 'ro', label='t = '+str(t_min))\n",
    "    ax[0].plot(dx*bubble_trajectory[-1], bubble_height[-1], 'yo', label='t = '+str(t_max))\n",
    "    ax[0].set_xlim((0,lenLat)); ax[0].set_xlabel(r'$x$'); ax[0].set_ylabel(r'Max '+str(titles[col]))\n",
    "    ax[0].grid(); ax[0].legend()\n",
    "\n",
    "    col = 1\n",
    "    momentum_simulation = [all_real_data[sim][col][t] for t in time_list]\n",
    "    smooth_momentum_simulation = [smoothen(field_slice, sigma) for field_slice in momentum_simulation]\n",
    "    bubble_momentum_trajectory = bubble_trajectory\n",
    "    bubble_momentum_height = [smooth_momentum_simulation[t][bubble_trajectory[t]] for t in range(len(time_list))]\n",
    "\n",
    "    ax[1].plot(dx*np.asarray(bubble_momentum_trajectory), bubble_momentum_height, 'ko-', ms=3)\n",
    "    ax[1].plot(dx*bubble_momentum_trajectory[0], bubble_momentum_height[0], 'ro', label='t = '+str(t_min))\n",
    "    ax[1].plot(dx*bubble_momentum_trajectory[-1], bubble_momentum_height[-1], 'yo', label='t = '+str(t_max))\n",
    "    ax[1].set_xlim((0,lenLat)); ax[1].set_xlabel(r'$x$'); ax[1].set_ylabel(r'Max '+str(titles[col]))\n",
    "    ax[1].grid(); ax[1].legend(); plt.show()\n",
    "    return #bubble_trajectory, bubble_height\n",
    "\n",
    "def plot_surviving_fraction(sim, sigma, t_min, t_max, threshold):\n",
    "    plt.figure(figsize=(7, 5))\n",
    "    simulation = all_real_data[sim][0]\n",
    "    time_list = np.arange(len(simulation)).tolist()\n",
    "    count = [masked_field_slice(simulation[timeslice], threshold)[-1] for timeslice in range(len(simulation))]\n",
    "    fraction = [c/nLat for c in count]\n",
    "\n",
    "    plt.plot(np.asarray(time_list), fraction, 'ko-', ms=3)\n",
    "    plt.plot(time_list.index(t_min), fraction[time_list.index(t_min)], 'ro', label='t = '+str(time_list.index(t_min)))\n",
    "    plt.plot(time_list.index(t_max), fraction[time_list.index(t_max)], 'yo', label='t = '+str(time_list.index(t_max)))\n",
    "\n",
    "    smooth_count = [masked_field_slice(smoothen(simulation[timeslice], sigma), threshold)[-1] for timeslice in range(len(simulation))]\n",
    "    smooth_fraction = [c/nLat for c in smooth_count]\n",
    "    plt.plot(np.asarray(time_list), smooth_fraction, color='dimgray', marker='o', ls='-', ms=3)\n",
    "    plt.plot(time_list.index(t_min), smooth_fraction[time_list.index(t_min)], 'ro')\n",
    "    plt.plot(time_list.index(t_max), smooth_fraction[time_list.index(t_max)], 'yo')\n",
    "    plt.ylabel(r'Fraction above threshold = {:.2f}'.format(threshold)); plt.xlabel(r'$t$')\n",
    "    plt.legend(); plt.grid(); plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Choose sample simulation for data analysis\n",
    "sim_selection = simsel\n",
    "sim_eg = sim_selection[0]\n",
    "\n",
    "lim_bubble = 0.2\n",
    "sigma = 1 / (dk * 8)\n",
    "\n",
    "t_min, t_max = time_limits_of_bubble(sim_eg, lim_bubble)\n",
    "#t_min = time_of_bubble_start(sim_eg, lim_bubble)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "#plot_simulation(sim_eg, sigma, t_min, t_max)\n",
    "#plot_chosen_field_slices(sim_eg, sigma, t_min, t_max)\n",
    "\n",
    "#plot_field_and_momentum_slice(sim_eg, sigma, t_max)\n",
    "\n",
    "#plot_max_trajectory(sim_eg, sigma, t_min, t_max)\n",
    "\n",
    "#threshold = right_phi_at_V_max.x\n",
    "#plot_surviving_fraction(sim_eg, sigma, t_min, t_max, threshold)\n",
    "\n",
    "#animate_field(field_simulation, field_simulation, t_min, t_max)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Finding trajectory of single peaks within simulation "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_average_bubble_profile(trajectory):\n",
    "    field_list_in_reverse = [field_in_simulation[::-1] for field_in_simulation in trajectory[0]]\n",
    "    momentum_list_in_reverse = [field_in_simulation[::-1] for field_in_simulation in trajectory[1]]\n",
    "    xerr = np.nanstd(np.array(list(zip_longest(*field_list_in_reverse)), dtype=float), axis=1, ddof=1)\n",
    "    xerr = [x for x in xerr if str(x) != 'nan'][::-1]\n",
    "    average_field = np.nanmean(np.array(list(zip_longest(*field_list_in_reverse)), dtype=float), axis=1)[:len(xerr)][::-1]\n",
    "    yerr = np.nanstd(np.array(list(zip_longest(*momentum_list_in_reverse)), dtype=float), axis=1, ddof=1)\n",
    "    yerr = [y for y in yerr if str(y) != 'nan'][::-1]\n",
    "    average_momentum = np.nanmean(np.array(list(zip_longest(*momentum_list_in_reverse)), dtype=float), axis=1)[:len(yerr)][::-1]\n",
    "    return average_field, average_momentum, xerr, yerr\n",
    "\n",
    "def trajectory_of_max(sim_selection, bubble_limit, sigma):\n",
    "    light_cone = sigma * dtout / dx # distance travelled by light in x axis within one time step\n",
    "    fld, mnt = [], []\n",
    "    for sim in sim_selection:\n",
    "        t_min, t_max = time_limits_of_bubble(sim, bubble_limit)\n",
    "#        t_min = time_of_bubble_start(sim, bubble_limit)\n",
    "        time_list = np.arange(t_min, t_max+1)\n",
    "\n",
    "        if t_max != nTime - 1:\n",
    "            field_simulation_sm = [smoothen(all_real_data[sim][0][t], sigma) for t in time_list[::-1]]\n",
    "            momentum_simulation_sm = [smoothen(all_real_data[sim][1][t], sigma) for t in time_list[::-1]]\n",
    "\n",
    "            # t = t_max case:\n",
    "            target_peak = find_max_peak(field_simulation_sm[0])[0]\n",
    "            peak_field_traj = [field_simulation_sm[0][target_peak]]\n",
    "            peak_momentum_traj = [momentum_simulation_sm[0][target_peak]]\n",
    "\n",
    "            multiplier = 1.\n",
    "            for t in range(1, len(time_list)):\n",
    "                # produce the future causal lightcone for the peak propagation\n",
    "                possible_peaks = []\n",
    "                distance_to_next_peak = light_cone * multiplier\n",
    "                left_ray = target_peak - light_cone * multiplier\n",
    "                right_ray = target_peak + light_cone * multiplier\n",
    "\n",
    "                peak_coords_on_slice = find_peak_positions(field_simulation_sm[t], phi_initial)\n",
    "                for peak in peak_coords_on_slice:\n",
    "                    if ((left_ray <= peak <= right_ray) or \n",
    "                        (left_ray < 0 and left_ray <= peak - nLat <= right_ray) or \n",
    "                        (right_ray >= nLat and left_ray <= peak + nLat <= right_ray)):\n",
    "                        if np.abs(target_peak - peak) < distance_to_next_peak:\n",
    "                            distance_to_next_peak = np.abs(target_peak - peak)\n",
    "                            possible_peaks.append(peak)\n",
    "                if possible_peaks != []:\n",
    "                    target_peak = possible_peaks[-1]\n",
    "                    if peak_field_traj[-1]*0.8 <= field_simulation_sm[t][target_peak] <= peak_field_traj[-1]*1.2:\n",
    "#                    if field_simulation_sm[t][target_peak] > phi_initial + (right_phi_at_V_max.x - phi_initial) / 2.:\n",
    "                        peak_field_traj.append(field_simulation_sm[t][target_peak])\n",
    "                        peak_momentum_traj.append(momentum_simulation_sm[t][target_peak])\n",
    "                        multiplier = 1.\n",
    "                    else:\n",
    "                        peak_field_traj = []\n",
    "                        break\n",
    "                else:\n",
    "                    multiplier += 1. # if we do find a peak within the lightcone, reset multiplier\n",
    "            if peak_field_traj != []:\n",
    "                fld.append(peak_field_traj[::-1])\n",
    "                mnt.append(peak_momentum_traj[::-1])\n",
    "    return fld, mnt\n",
    "\n",
    "def plot_trajectory_of_max(boolean, sim_selection, bubble_limit, sigma):\n",
    "    trajectory = trajectory_of_max(sim_selection, bubble_limit, sigma)\n",
    "    fld = trajectory[0]; mnt = trajectory[1]\n",
    "    print('# trajectories: ' + str(len(fld)) + ' = ' + '# simulations: ' + str(len(sim_selection)))\n",
    "    print(len(fld) == len(sim_selection))\n",
    "\n",
    "    fig = plt.figure(figsize=(7,5))\n",
    "    for sim in range(len(fld)):\n",
    "        plt.plot(fld[sim], mnt[sim], 'o-', ms = 3)\n",
    "    plt.axvline(right_phi_at_V_max.x)\n",
    "    plt.axvline(np.pi, color = 'y', ls = '-')\n",
    "    plt.axvline(2*np.pi, color = 'y', ls = '-')\n",
    "    plt.xlabel(r'$\\phi(x)$')\n",
    "    plt.ylabel(r'$\\partial_t \\phi(x)$')\n",
    "    plt.savefig(plots_file+'trajectory_of_max_bundle'+suffix+'.png');\n",
    "    plt.grid(); plt.show()\n",
    "\n",
    "    fig = plt.figure(figsize=(7,5))\n",
    "    average_field, average_momentum, xerr, yerr = find_average_bubble_profile(trajectory)\n",
    "    plt.errorbar(average_field, average_momentum, xerr = xerr, yerr = yerr, color = 'k', marker='o', ecolor = 'green')\n",
    "    plt.axvline(right_phi_at_V_max.x)\n",
    "    plt.axvline(np.pi, color = 'y', ls = '-')\n",
    "    plt.axvline(2*np.pi, color = 'y', ls = '-')\n",
    "    plt.xlabel(r'Average $\\phi(x)$ of bubble peak')\n",
    "    plt.ylabel(r'Average $\\partial_t \\phi(x)$ of bubble peak')\n",
    "    plt.savefig(plots_file+'trajectory_of_max'+suffix+'.png');\n",
    "    plt.grid(); plt.show()\n",
    "\n",
    "    if boolean:\n",
    "        for sim in range(len(fld)):\n",
    "            fig = plt.figure(figsize=(7,5))\n",
    "            plt.plot(fld[sim], mnt[sim], 'o-', ms = 3)\n",
    "            plt.axvline(right_phi_at_V_max.x)\n",
    "            plt.axvline(np.pi, color = 'y', ls = '-')\n",
    "            plt.axvline(2*np.pi, color = 'y', ls = '-')\n",
    "            plt.xlabel(r'$\\phi(x)$')\n",
    "            plt.ylabel(r'$\\partial_t \\phi(x)$')\n",
    "            plt.grid(); plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "#plot_trajectory_of_max(False, sim_selection, lim_bubble, sigma)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Average bubble"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "def truncateNum(num, decimal_places):\n",
    "    StrNum = str(num)\n",
    "    p = StrNum.find(\".\") + 1 + decimal_places\n",
    "    return ( StrNum[0:p] )\n",
    "\n",
    "def cut_out_coordinates(sim_selection, bubble_limit):\n",
    "    bubble_data = []\n",
    "    for sim in sim_selection:\n",
    "#       t_min, t_max = time_limits_of_bubble(sim, bubble_limit)\n",
    "        breakLoop = False\n",
    "        t_min, t_max = [], []\n",
    "        for t in range(nTime):\n",
    "            if not breakLoop:\n",
    "                true_V = 0\n",
    "                for V_phi in all_real_data[sim][-1][t]:\n",
    "                    if V_phi < V(np.pi): \n",
    "                        true_V += 1\n",
    "                if true_V >= nLat * 0.04 :\n",
    "                    t_min.append(t)\n",
    "                if (true_V >= nLat * 0.07 or t == nTime-1) :\n",
    "                    t_max.append(t)\n",
    "                if (true_V >= nLat * bubble_limit or t == nTime-1) :\n",
    "                    t_end = t\n",
    "                    t_beginning = t_end - 250\n",
    "                    if t_beginning < 0 : t_beginning = 0\n",
    "                    breakLoop = True\n",
    "\n",
    "        if t_min != []:\n",
    "            time_list_averaging = np.arange(min(t_min), min(t_max)+1)[::-1]\n",
    "            print(len(time_list_averaging))\n",
    "            time_bubble = np.arange(t_beginning, t_end+1)[::-1]\n",
    "            peak_list = []\n",
    "            if (t_end != nTime-1) and (t_beginning != 0):\n",
    "#                filter_size = 1 / (dk * 5)\n",
    "                for t in time_list_averaging:\n",
    "#                    potential_slice = all_real_data[sim][-1][t]\n",
    "#                    bubble_position_at_t = [x for x in range(len(potential_slice)) if potential_slice[x] < V(np.pi)]\n",
    "                    field_slice = all_real_data[sim][0][t]\n",
    "                    bubble_position_at_t = [x for x in range(len(field_slice)) if field_slice[x] > math.floor(phi_bound)]\n",
    "                    if len(bubble_position_at_t) > 0:\n",
    "                        peak_list.append(np.mean(bubble_position_at_t))\n",
    "\n",
    "                target_peak = int(round(np.mean(peak_list)))\n",
    "                if stat.stdev(peak_list) < nLat*0.01:\n",
    "                    left = target_peak - nLat//2\n",
    "                    right = target_peak + nLat//2\n",
    "                    # periodic boundary conditions\n",
    "                    if left >= 0 and right < nLat: \n",
    "                        coord_list = np.arange(nLat)[left:right]\n",
    "                    elif left < 0 and right < nLat: \n",
    "                        coord_list = np.arange(nLat)[left+nLat:].tolist() + np.arange(nLat)[:right].tolist()\n",
    "                    elif left >= 0 and right >= nLat: \n",
    "                        coord_list = np.arange(nLat)[left:].tolist() + np.arange(nLat)[:right-nLat].tolist()\n",
    "                    bubble_data.append((sim, coord_list, time_bubble))\n",
    "    print('# valid simulations: ', len(bubble_data))\n",
    "    return bubble_data\n",
    "\n",
    "def stack_bubbles(overall_bubble_data, col):\n",
    "    bubbles, time, average_bubble, average_bubble_error = [], [], [], []\n",
    "    for bubble_data in overall_bubble_data:\n",
    "        simulation, coord_list, time_bubble = bubble_data\n",
    "        if col != 1:\n",
    "            field = [[all_real_data[simulation][col][t][i] for i in coord_list] for t in time_bubble]\n",
    "        else:\n",
    "            field = [[all_real_data[simulation][col][t][i]**2 for i in coord_list] for t in time_bubble]\n",
    "        bubbles.append(field)\n",
    "        time.append(len(time_bubble))\n",
    "        n_coord = len(coord_list)\n",
    "\n",
    "    field = [ [ [ t for t in range(time[sim]) ] for sim in range(len(bubbles)) ] for coord in range(n_coord)]\n",
    "    for coord in range(n_coord):\n",
    "        for sim in range(len(bubbles)):\n",
    "            for t in range(time[sim]):\n",
    "                field[coord][sim][t] = bubbles[sim][t][coord]\n",
    "    for coordinate in field:\n",
    "        xerr_field = np.nanstd(np.array(list(zip_longest(*coordinate)), dtype=float), axis=1, ddof=1)\n",
    "        xerr_field = [x for x in xerr_field if str(x) != 'nan'][::-1]\n",
    "        average_bubble_error.append(xerr_field)\n",
    "        mean_field = np.nanmean(np.array(list(zip_longest(*coordinate)), dtype=float), axis=1)\n",
    "        average_bubble.append(mean_field[:len(xerr_field)][::-1])\n",
    "    return np.transpose(average_bubble, (1, 0)), np.transpose(average_bubble_error, (1, 0)), min(time)\n",
    "\n",
    "def coleman_match(average_bubble):\n",
    "    # Coleman solution from Mathematica file: ColemanBubble\n",
    "    decimal_places = 5\n",
    "    x_list = [x for x in range(len(coleman_bubble[0])) if truncateNum(coleman_bubble[0][x], decimal_places) != truncateNum(np.pi, decimal_places)]\n",
    "    y_list = [x for x in range(len(coleman_bubble[0])) if truncateNum(coleman_bubble[0][x], decimal_places) == truncateNum(2*np.pi, decimal_places)]\n",
    "    coord_list = [x for x in range(len(coleman_bubble[0])) if (x in x_list and x not in y_list)]\n",
    "    min_sum = np.sum(coleman_bubble[0])\n",
    "    min_t = 0\n",
    "    for t in range(len(average_bubble)):\n",
    "        a = sum([np.abs(average_bubble[t][x] - coleman_bubble[0][x]) for x in coord_list])\n",
    "        if min_sum > a:\n",
    "            min_sum = a\n",
    "            min_t = t\n",
    "    return min_t, min(x_list), max(x_list)#, min(y_list), max(y_list)\n",
    "    \n",
    "def plot_coleman_match(ab):\n",
    "    average_bubble, average_bubble_error, common_time = ab\n",
    "    t_coleman, a, b = coleman_match(average_bubble)\n",
    "    print('shape of bubble: ', np.shape(average_bubble))\n",
    "    print('t_coleman = ', t_coleman)\n",
    "    solution = average_bubble[t_coleman]\n",
    "    solution_error = average_bubble_error[t_coleman]\n",
    "    difference = [coleman_bubble[0][i] - solution[i] for i in range(len(coleman_bubble[0]))]\n",
    "\n",
    "    fig = plt.figure(figsize=(12,4)); plt.subplots_adjust(hspace=.0)\n",
    "    gs = gridspec.GridSpec(1, 2); ax = [[],[]]\n",
    "    ax[0] = plt.subplot(gs[0]); ax[1] = plt.subplot(gs[1])\n",
    "\n",
    "    im = ax[0].imshow(average_bubble, aspect='auto', interpolation='none', origin='lower')#, extent=[0, dx*len(average_bubble[0]), 0, dtout*len(average_bubble)])     \n",
    "    clb = plt.colorbar(im, ax = ax[0])\n",
    "    ax[0].set(xlabel = r'$x$', ylabel=r'$t$')\n",
    "    ax[0].plot(np.arange(len(solution)), np.ones(len(solution))*t_coleman, 'r-')\n",
    "    ax[0].plot(np.arange(len(solution)), np.ones(len(solution))*(len(average_bubble)-common_time), color='darkgray', ls='-', linewidth=0.5)\n",
    "\n",
    "    mask = []\n",
    "    for t in range(len(coleman_bubble)):\n",
    "        mask.append([])\n",
    "        for x in range(len(coleman_bubble[-1])):\n",
    "            if coleman_bubble[t][x] != 0.:\n",
    "                mask[-1].append(1.)\n",
    "            else:\n",
    "                mask[-1].append(0.)\n",
    "    extra_t = len(coleman_bubble)\n",
    "    if t_coleman + extra_t >= len(average_bubble):\n",
    "        extra_t = len(average_bubble) - t_coleman\n",
    "#    x, y = np.meshgrid(range(len(mask[0])), range(len(mask[:extra_t])))\n",
    "#    ax.contour(x, y, mask[:extra_t], levels=[0.5, 1.5], colors=('k',), linewidths=(1.5,), origin='lower')\n",
    "    im = ax[1].imshow((average_bubble[t_coleman:(t_coleman+extra_t):1]-coleman_bubble[:extra_t])*mask[:extra_t], aspect='auto', interpolation='none', origin='lower')#, extent=[0, dx*len(average_bubble[0]), 0, dtout*(len(average_bubble)-t_coleman)])\n",
    "    clb = plt.colorbar(im, ax = ax[1])\n",
    "    ax[1].set(xlabel = r'$x$', ylabel=r'$t$')\n",
    "    plt.savefig(plots_file+'bubble_solution_'+suffix+'.png');\n",
    "    plt.show()\n",
    "\n",
    "    fig = plt.figure(figsize=(10,5))\n",
    "    plt.errorbar(np.arange(len(solution)), solution, yerr = solution_error, color = 'k', marker='o', ms=1, ecolor = 'green', label = 'Average bubble')\n",
    "    plt.plot(np.arange(len(coleman_bubble[0])), coleman_bubble[0], 'r-', linewidth=5.0, label = 'Coleman best fit at t = '+str(t_coleman))\n",
    "    plt.errorbar(np.arange(len(coleman_bubble[0])), difference, yerr = solution_error, color = 'k', marker='o', ms=1, ecolor = 'yellow', label = 'Difference')\n",
    "    plt.axvline(a, color = 'darkgray', ls = '--'); plt.axvline(b, color = 'darkgray', ls = '--')\n",
    "#    plt.axvline(c, color = 'darkgray', ls = '--'); plt.axvline(d, color = 'darkgray', ls = '--')\n",
    "    plt.legend(); plt.grid()\n",
    "    plt.savefig(plots_file+'bubble_profile_'+suffix+'.png');\n",
    "    plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "def bubble_energies(bubble, bubble_mom_sq, bubble_gradient, bubble_potential):\n",
    "    average_bubble = bubble[0]; KED = 0.5*bubble_mom_sq[0]; GED = 0.5*bubble_gradient[0]; PED = bubble_potential[0]\n",
    "    return KED, GED, PED, KED + GED + PED\n",
    "\n",
    "def bubble_total_energy(bubble, bubble_mom_sq, bubble_gradient, bubble_potential):\n",
    "    energies = bubble_energies(bubble, bubble_mom_sq, bubble_gradient, bubble_potential)\n",
    "    return [ [sum(ED[t]) for t in range(len(ED))] for ED in energies ]\n",
    "\n",
    "def plot_total_energy_density(bubble, bubble_mom_sq, bubble_gradient, bubble_potential):\n",
    "    KED, GED, PED, TED = bubble_energies(bubble, bubble_mom_sq, bubble_gradient, bubble_potential)\n",
    "    t_coleman = coleman_match(bubble[0])[0]\n",
    "\n",
    "    fig = plt.figure(figsize=(15,10)); gs = gridspec.GridSpec(2, 2); ax = [[],[], [], []]\n",
    "    ax[0] = plt.subplot(gs[0]); ax[1] = plt.subplot(gs[1]); ax[2] = plt.subplot(gs[2]); ax[3] = plt.subplot(gs[3])\n",
    "    im = ax[0].imshow(KED, aspect='auto', interpolation='none', origin='lower')   \n",
    "    ax[0].plot(np.arange(len(bubble[0][t_coleman])), np.ones(len(bubble[0][t_coleman]))*t_coleman, 'r-')\n",
    "    clb = plt.colorbar(im, ax = ax[0]); ax[0].set_title(r'KED: $\\frac{1}{2}(\\partial_t \\phi)^2$'); ax[0].set(ylabel=r'$t$')\n",
    "    im = ax[1].imshow(GED, aspect='auto', interpolation='none', origin='lower')   \n",
    "    ax[1].plot(np.arange(len(bubble[0][t_coleman])), np.ones(len(bubble[0][t_coleman]))*t_coleman, 'r-')\n",
    "    clb = plt.colorbar(im, ax = ax[1]); ax[1].set_title(r'GED: $\\frac{1}{2}|\\nabla \\phi|^2$')\n",
    "    im = ax[2].imshow(PED, aspect='auto', interpolation='none', origin='lower')   \n",
    "    ax[2].plot(np.arange(len(bubble[0][t_coleman])), np.ones(len(bubble[0][t_coleman]))*t_coleman, 'r-')\n",
    "    clb = plt.colorbar(im, ax = ax[2]); ax[2].set_title(r'PED: $V(\\phi)$'); ax[2].set(xlabel = r'$x$', ylabel=r'$t$')\n",
    "    im = ax[3].imshow(TED, aspect='auto', interpolation='none', origin='lower')   \n",
    "    ax[3].plot(np.arange(len(bubble[0][t_coleman])), np.ones(len(bubble[0][t_coleman]))*t_coleman, 'r-')\n",
    "    clb = plt.colorbar(im, ax = ax[3]); ax[3].set_title(r'TED: $\\frac{1}{2}\\left[(\\partial_t \\phi)^2 +|\\nabla \\phi|^2\\right] +V(\\phi)$'); ax[3].set(xlabel = r'$x$')\n",
    "    plt.savefig(plots_file+'energy_densities'+suffix+'.png');\n",
    "    return\n",
    "\n",
    "def plot_total_energy(bubble, bubble_mom_sq, bubble_gradient, bubble_potential):\n",
    "    KE, GE, PE, TE = bubble_total_energy(bubble, bubble_mom_sq, bubble_gradient, bubble_potential)\n",
    "    t_coleman = coleman_match(bubble[0])[0]\n",
    "\n",
    "    fig = plt.figure(figsize=(5,4))\n",
    "    plt.plot(np.arange(len(KE)), KE, 'b-', label = 'KE')\n",
    "    plt.plot(np.arange(len(GE)), GE, 'g-', label = 'GE')\n",
    "    plt.plot(np.arange(len(PE)), PE, 'y-', label = 'PE')\n",
    "    plt.plot(np.arange(len(TE)), TE, 'r-', label = 'TE', linewidth=5.0)\n",
    "    plt.axhline(np.mean(TE), color = 'darkgray', ls = '--')\n",
    "    plt.axvline(t_coleman, color = 'darkgray', ls = '--')#, label=r'$t_C$')\n",
    "    plt.xlabel('$t$'); plt.ylabel(r'$TE = \\int dx$ TED'); plt.grid(); plt.legend()\n",
    "    plt.savefig(plots_file+'energy_balance'+suffix+'.png'); plt.show()\n",
    "    return\n",
    "\n",
    "def plot_bubble_profile(bubble, bubble_mom_sq, bubble_gradient, bubble_potential, timeslice):\n",
    "    KED, GED, PED, TED = bubble_energies(bubble, bubble_mom_sq, bubble_gradient, bubble_potential)\n",
    "    t_coleman = coleman_match(bubble[0])[0]\n",
    "    final_t = timeslice - t_coleman\n",
    "    \n",
    "    fig = plt.figure(figsize=(10,8)); plt.subplots_adjust(hspace=.0)\n",
    "    gs = gridspec.GridSpec(5, 1, height_ratios=[2, 1, 1, 1, 1])\n",
    "    ax = [[],[],[],[], []]; ax[0] = plt.subplot(gs[0])\n",
    "    ax[1] = plt.subplot(gs[1], sharex = ax[0]); ax[2] = plt.subplot(gs[2], sharex = ax[1])\n",
    "    ax[3] = plt.subplot(gs[3], sharex = ax[2]); ax[4] = plt.subplot(gs[4], sharex = ax[3])\n",
    "\n",
    "    ax[0].plot(np.arange(len(bubble[0][timeslice])), bubble[0][timeslice], 'ko', ms='3', label = 'Average Bubble at t = '+str(timeslice))\n",
    "    ax[1].plot(np.arange(len(PED[timeslice])), PED[timeslice], 'y-', label = 'PED')\n",
    "    ax[2].plot(np.arange(len(KED[timeslice])), KED[timeslice], 'b-', label = 'KED')\n",
    "    ax[3].plot(np.arange(len(GED[timeslice])), GED[timeslice], 'g-', label = 'GED')\n",
    "    ax[4].plot(np.arange(len(TED[timeslice])), TED[timeslice], 'r-', label = 'TED')\n",
    "\n",
    "    if final_t >= 0:\n",
    "        bubble_match = [i if i != 0. else None for i in coleman_bubble[final_t]]\n",
    "        first_line = coleman_bubble[final_t].tolist().index(0)\n",
    "        last_line = len(coleman_bubble[final_t]) - 1 - coleman_bubble[final_t][::-1].tolist().index(0)\n",
    "        ax[0].plot(np.arange(len(bubble_match)), bubble_match, 'r-', label = 'Coleman Bubble at t = '+str(timeslice))\n",
    "        ax[0].axvline(first_line, color = 'darkgray', ls = '--'); ax[0].axvline(last_line, color = 'darkgray', ls = '--')\n",
    "        ax[1].axvline(first_line, color = 'darkgray', ls = '--'); ax[1].axvline(last_line, color = 'darkgray', ls = '--')\n",
    "        ax[2].axvline(first_line, color = 'darkgray', ls = '--'); ax[2].axvline(last_line, color = 'darkgray', ls = '--')\n",
    "        ax[3].axvline(first_line, color = 'darkgray', ls = '--'); ax[3].axvline(last_line, color = 'darkgray', ls = '--')\n",
    "        ax[4].axvline(first_line, color = 'darkgray', ls = '--'); ax[4].axvline(last_line, color = 'darkgray', ls = '--')\n",
    "\n",
    "    ax[0].grid(); ax[0].legend(); ax[1].grid(); ax[1].legend()\n",
    "    ax[2].grid(); ax[2].legend(); ax[3].grid(); ax[3].legend()\n",
    "    ax[4].grid(); ax[4].legend(); ax[4].set(xlabel='$x$')\n",
    "    plt.savefig(plots_file+'bubble_profile_at_t'+str(timeslice)+suffix+'.png'); plt.show()\n",
    "    return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "coleman_bubble_file = pickle_location+'coleman_bubble_file'+suffix+'.npy'\n",
    "#coleman_bubble = \n",
    "#np.save(coleman_bubble_file, coleman_bubble)\n",
    "\n",
    "coleman_bubble = np.load(coleman_bubble_file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "# valid simulations:  0\n"
     ]
    },
    {
     "ename": "UnboundLocalError",
     "evalue": "local variable 'n_coord' referenced before assignment",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mUnboundLocalError\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-24-9ce84121a1be>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0mbubble_cutouts\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcut_out_coordinates\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msim_selection\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlim_bubble\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 5\u001b[0;31m \u001b[0mab\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mstack_bubbles\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbubble_cutouts\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      6\u001b[0m \u001b[0mabm\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mstack_bubbles\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbubble_cutouts\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      7\u001b[0m \u001b[0mabgsq\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mstack_bubbles\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbubble_cutouts\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-21-9c7921f5c1c1>\u001b[0m in \u001b[0;36mstack_bubbles\u001b[0;34m(overall_bubble_data, col)\u001b[0m\n\u001b[1;32m     67\u001b[0m         \u001b[0mn_coord\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcoord_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     68\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 69\u001b[0;31m     \u001b[0mfield\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m \u001b[0;34m[\u001b[0m \u001b[0;34m[\u001b[0m \u001b[0mt\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mt\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtime\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0msim\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m]\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0msim\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbubbles\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m]\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mcoord\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mn_coord\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     70\u001b[0m     \u001b[0;32mfor\u001b[0m \u001b[0mcoord\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mn_coord\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     71\u001b[0m         \u001b[0;32mfor\u001b[0m \u001b[0msim\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbubbles\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mUnboundLocalError\u001b[0m: local variable 'n_coord' referenced before assignment"
     ]
    }
   ],
   "source": [
    "lim_bubble = 0.11\n",
    "sim_selection = all_right_decaying_sims\n",
    "\n",
    "bubble_cutouts = cut_out_coordinates(sim_selection, lim_bubble)\n",
    "ab = stack_bubbles(bubble_cutouts, 0)\n",
    "abm = stack_bubbles(bubble_cutouts, 1)\n",
    "abgsq = stack_bubbles(bubble_cutouts, 2)\n",
    "abp = stack_bubbles(bubble_cutouts, 3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "timeslice = 55\n",
    "\n",
    "plot_coleman_match(ab)\n",
    "plot_bubble_profile(ab, abm, abgsq, abp, timeslice)\n",
    "plot_total_energy_density(ab, abm, abgsq, abp)\n",
    "plot_total_energy(ab, abm, abgsq, abp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from scipy.integrate import quad\n",
    "\n",
    "wall_tension, err = quad(lambda x: np.sqrt(2*(V(x) - V(2*np.pi))), np.pi, 2*np.pi)\n",
    "epsilon = V(np.pi) - V(2*np.pi)\n",
    "\n",
    "def total_energy_balace(r, dr):\n",
    "    velocity = dr * dx / dtout  # = np.sqrt( 1 - (r0/r)**2 )\n",
    "    bubble_area = 2      #4.*np.pi * r**2\n",
    "    bubble_volume = 2*r      #4.*np.pi * r**3 / 3.\n",
    "    relativistic_factor = np.sqrt(1 - velocity**2)\n",
    "    return bubble_area * wall_tension / relativistic_factor - bubble_volume * epsilon\n",
    "\n",
    "def total_energy(bubble, bubble_mom_sq, bubble_gradient, bubble_potential, timeslice):\n",
    "    TED = bubble_energies(bubble, bubble_mom_sq, bubble_gradient, bubble_potential)[-1]\n",
    "    return sum(TED[timeslice]) - sum(TED[0])\n",
    "\n",
    "def extract_radius(bubble, timeslice):\n",
    "    curve = bubble[0][timeslice]\n",
    "#    curve = coleman_bubble[0]\n",
    "    peaks, _ = scs.find_peaks(curve)\n",
    "    results_half = scs.peak_widths(curve, peaks, rel_height=0.5)\n",
    "#    plt.plot(curve); plt.plot(peaks, curve[peaks], \"x\"); plt.hlines(*results_half[1:], color=\"C2\"); plt.show()\n",
    "    return int(round(max(results_half[0])/2.))\n",
    "\n",
    "def field_ansatz(r, r0, dr):\n",
    "    return ((np.tanh((r0 - r) / dr * 2) + 3)*np.pi/2)\n",
    "\n",
    "def extract_dr(bubble, bubble_mom_sq, bubble_gradient, bubble_potential, timeslice):\n",
    "    fit = total_energy(bubble, bubble_mom_sq, bubble_gradient, bubble_potential, timeslice)\n",
    "    r = extract_radius(bubble, timeslice)\n",
    "    decimal_places = 3\n",
    "    for dr in np.linspace(0, 0.1, 1000000):\n",
    "        case = 2*wall_tension / np.sqrt( 1 - (dr*dx/dtout)**2 ) - 2*r*epsilon\n",
    "        if truncateNum(case, decimal_places) == truncateNum(fit, decimal_places) :\n",
    "            return dr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "extract_dr(ab, abm, abgsq, abp, t_coleman)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### A section of the bubble wall at rest carries energy wall_tension per unit area.\n",
    "\n",
    ". Any part of the bubble wall at any time is obtained from any other part by a Lorentz transformation\n",
    "\n",
    ". Thus a section of wall expanding with velocity v carries energy wall_thickness / np.sqrt( 1-v**2 ) per unit area\n",
    "\n",
    ". Velocity v = dr/dt = np.sqrt( 1 - (r0/r)**2 ), where r is the radius of the bubble at time t"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "t_coleman = coleman_match(ab[0])[0]+52\n",
    "r0 = extract_radius(ab, t_coleman)\n",
    "\n",
    "print(total_energy_balace(r0, 0.25*dtout))\n",
    "print(total_energy(ab, abm, abgsq, abp, t_coleman))\n",
    "\n",
    "plt.plot(np.linspace(0, 0.1, 10000), [total_energy_balace(r0, t*dtout) for t in np.linspace(0, 0.1, 10000)])\n",
    "plt.axhline(0, 'r')\n",
    "plt.grid()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "t_coleman = coleman_match(ab[0])[0]\n",
    "r0 = extract_radius(ab, t_coleman)\n",
    "th_r0 = 3 * wall_tension / epsilon\n",
    "\n",
    "m = nLat\n",
    "\n",
    "profile_ansatz = [field_ansatz(r, r0, 600*dtout) for r in range(m//2)]\n",
    "plt.plot(np.arange(m), profile_ansatz[::-1]+profile_ansatz)\n",
    "plt.axhline(2*np.pi)\n",
    "plt.plot(r0+m//2-1, profile_ansatz[int(round(r0))], 'ro')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.7 (conda) - recommended",
   "language": "python",
   "name": "python37-conda"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
